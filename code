//+------------------------------------------------------------------+
//| GoldenFinale_v3_Enhanced_Complete.mq5
//+------------------------------------------------------------------+
#property copyright "Golden Finale EA v3.0 Enhanced - Complete Version"
#property version "3.08"
#property strict // This line is already present and correct.
#include <Trade\Trade.mqh> // Correct include path for Trade class.
#include <Trade\PositionInfo.mqh> // Correct include path for PositionInfo class.
#include <Trade\SymbolInfo.mqh> // Correct include path for SymbolInfo class.
#include <Trade\AccountInfo.mqh> // Correct include path for AccountInfo class.

enum ENUM_SYSTEM_TYPE{SYSTEM_NONE,SYSTEM_TURBO,SYSTEM_FORCE,SYSTEM_HFT,SYSTEM_USTP,SYSTEM_BOOST,SYSTEM_RANGE,SYSTEM_SCALPING,SYSTEM_INDICATOR,SYSTEM_AI};
enum ENUM_HFT_MODE{MODE_CONFIRMATION,MODE_TIMING,MODE_SMART,MODE_AGGRESSIVE};
enum ENUM_LOG_LEVEL{LOG_DEBUG,LOG_INFO,LOG_WARNING,LOG_ERROR};
enum ENUM_AI_MODE{AI_OFF,AI_HAIKU,AI_SONNET,AI_ADAPTIVE};
enum ENUM_NEWS_IMPACT{NEWS_LOW = 1,NEWS_MEDIUM,NEWS_HIGH};

struct NewsEvent{datetime time;string currency;string title;ENUM_NEWS_IMPACT impact;double forecast;double previous;double actual;bool processed;};
struct AIAnalysis{datetime time;int marketState;int suggestedAction;double volatility;double predictedMove;double riskScore;double suggestedLotMultiplier;double confidence;string marketContext;bool newsExpected;};
struct EmergencyAction{bool required;string reason;int actionType;double urgency;};
struct DynamicSettings{int originalMaxTrades;int currentMaxTrades;double originalPortfolioTarget;double currentPortfolioTarget;double modificationConfidence;string lastModificationReason;datetime lastModificationTime;datetime overrideTime;bool protectionOverridden;string overrideReason;};
struct SessionTiming{int asianHaikuSeconds;int asianSonnetMinutes;int europeanHaikuSeconds;int europeanSonnetMinutes;int americanHaikuSeconds;int americanSonnetMinutes;bool emergencySonnetOnly;};
struct SafeTickInfo{double price;datetime time;long volume;double spread;bool valid;};
struct SafeHFTData{double spread,velocity,momentum1s,momentum5s,momentum30s,volatility,volumeStrength,gapAnalysis,confidence,suggestedLot,depthImbalance,microStructureScore;int direction,suggestedTP,suggestedSL;bool shouldEnter,isValid;string pattern;};
struct RangeData{double high,low,size,quality,fibo382Level,fibo618Level;bool isValid,breakoutDetected;int strength;double confidence;};
struct VolumeBoostSignal{bool active;int direction,confirmations;double confidence,suggestedMultiplier,volumeRatio;datetime validUntil;string reason;};
struct TurboSignal{bool active,aggressiveMode;int direction;double confidence,adxStrength,suggestedMultiplier;string timeframes;};
struct ScalpingSignal{bool active,smartExitReady;int direction;double confidence,entryPrice,targetPrice;string pattern;};
struct ForceRecoveryData{int consecutiveLosses,recoveryAttempts;double totalLossAmount,recoveryMultiplier;bool emergencyMode;datetime lastAttempt;double confidence;};
struct PortfolioHealth{double score,riskLevel,profitability,stability,diversity;string recommendation;};
struct USTPPrediction{int direction;double confidence,expectedMove;string reason;datetime validUntil;};
struct ExternalAPIData{double price;double volume;double momentum;string trend;string sentiment;bool dataValid;datetime lastUpdate;};
struct RiskMetrics{double maxDrawdown,currentDrawdown,maxOpenLoss,maxDailyLoss,marginLevel,sharpeRatio,riskRewardRatio;int consecutiveLosses;bool riskExceeded;};
struct SystemActivity{datetime lastOpen;bool isActive;int tradesOpen;double totalProfit;};

#define EVENT_ULTRA_BALANCE_TRIGGERED 1001
#define EVENT_HFT_SIGNAL 1002
#define EVENT_BOOST_SIGNAL 1003
#define EVENT_TURBO_SIGNAL 1004
#define EVENT_FORCE_SIGNAL 1005
#define EVENT_SCALPING_SIGNAL 1006
#define EVENT_USTP_SIGNAL 1007
#define EVENT_RANGE_SIGNAL 1008
#define EVENT_AI_SIGNAL 1009
#define EVENT_NEWS_ALERT 1010
#define EVENT_EMERGENCY_INTERVENTION 1011
#define EVENT_SETTINGS_MODIFIED 1012
#define EVENT_PROTECTION_OVERRIDE 1013
#define EVENT_SESSION_CHANGE 1014
#define AI_APIKey "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"
#define AI_ModelName "Orioto.ai/live" // Model name used for AI
#define AI_MaxDailyCalls 3000

input group "=== إعدادات الذكاء الاصطناعي ===" // إعدادات الذكاء الاصطناعي
input ENUM_AI_MODE AI_Mode=AI_ADAPTIVE; // AI Mode (Off, Haiku, Sonnet, Adaptive)
input int AI_FastAnalysisSeconds=30; // Fast Analysis Interval in Seconds
input int AI_DeepAnalysisMinutes=5; // Deep Analysis Interval in Minutes
input double AI_MinActionConfidence=65.0; // Minimum AI Confidence for Action
input bool AI_AutoAdjustLots=true; // Should AI automatically adjust lot size?
input bool AI_NewsIntegration=true; // Should AI integrate news data?
input bool AI_EmergencyOverride=true; // Can AI override emergency procedures?
input bool AI_LearnFromHistory=true; // Should AI learn from historical data?
input bool AI_FullControl=true; // Does AI have full control over trading?
input bool AI_SessionAware=true; // Should AI be aware of market sessions?
input bool AI_DirectTrading=true; // Can AI open and close trades directly?
input int AI_MaxPositions=100; // Maximum number of open positions AI can manage
input bool AI_AutoFixVolume=true; // Should AI automatically fix invalid lot sizes?
input bool AI_MonitorJournal=true; // Should AI monitor MetaTrader journal for errors?
input bool AI_UseExternalAPIs=true; // Should AI use external APIs?
input string AI_ExternalAPI_Key=""; // API Key for external services (if required)

input group "=== تحليل الأخبار ===" // تحليل الأخبار
input bool NEWS_Enable=true;
input bool NEWS_HighImpactOnly=false;
input int NEWS_MinutesBeforeEvent=30;
input int NEWS_MinutesAfterEvent=60;
input bool NEWS_AutoCloseBeforeHigh=true;
input double NEWS_VolatilityMultiplier=2.0;

input group "=== نظام USTP ===" // نظام USTP
input bool USTP_Enable=true;
input int USTP_PredictionMinutes=1;
input double USTP_MinConfidence=60.0;
input int USTP_MinSignalGap=5;
input double USTP_MinMomentum=10.0;
input double USTP_MaxVolatility=50.0;
input int USTP_MaxDailySignals=99999;
input bool USTP_UseTickAnalysis=true;
input bool USTP_UseOrderFlow=true;
input bool USTP_UseMicroStructure=true;

input group "=== التوازن الفائق ===" // التوازن الفائق
input bool ULTRA_Enable=true;
input double ULTRA_MinLossToBalance=10.0;
input double ULTRA_BalanceMultiplier=1.5;
input int ULTRA_CheckIntervalMS=500;
input double ULTRA_MaxBalanceLot=0.3;
input int ULTRA_MaxBalanceTrades=5;
input double ULTRA_MinProfitPips=100.0;
input double ULTRA_EmergencyLossLevel=300.0;
input double ULTRA_MinADXForEntry=20.0;
input double ULTRA_MaxSpreadForEntry=200.0;
input double ULTRA_MaxRiskPercent=10.0;
input bool ULTRA_UseAllSystems=true;
input bool ULTRA_RequireStrongSignal=false;
input double ULTRA_MaxOpenLoss=500.0;
input double ULTRA_ExceptionalMaxLoss=300.0;

input group "=== الصفقات الاستثنائية ===" // الصفقات الاستثنائية
input bool EXCEPT_Enable=true;
input int EXCEPT_MaxTrades=2;
input double EXCEPT_MinLoss=20.0;
input double EXCEPT_Multiplier=1.8;
input double EXCEPT_MinConfidence=80.0;
input int EXCEPT_Cooldown=300;

input group "=== تعزيز الحجم ===" // تعزيز الحجم
input bool BOOST_Enable=true;
input double BOOST_MinConfidence=85.0;
input double BOOST_Multiplier=2.0;
input int BOOST_MaxDailyTrades=99999;
input double BOOST_MaxLot=0.3;
input int BOOST_MinADX=30;
input double BOOST_VolumeRatioMin=1.5;
input bool BOOST_RequireMultiConfirm=true;

input group "=== نظام التداول السريع HFT ===" // نظام التداول السريع HFT
input bool HFT_Enable=true;
input int HFT_MaxDaily=99999;
input double HFT_MinConfidence=60.0;
input int HFT_WaitSeconds=5;
input double HFT_SpreadFactor=1.5;
input ENUM_HFT_MODE HFT_Mode=MODE_AGGRESSIVE;
input bool HFT_UseUltraPrediction=true;
input bool HFT_UseDepthAnalysis=true;

input group "=== إدارة المحفظة ===" // إدارة المحفظة
input bool PORTFOLIO_Enable=true;
input double PORTFOLIO_TargetProfit=100.0;
input double PORTFOLIO_MinProfitToClose=50.0;
input int PORTFOLIO_CheckInterval=10;
input double PORTFOLIO_MinProfitPerTrade=2.0;
input double PORTFOLIO_MinHealthScore=30.0;
input bool PORTFOLIO_UseHealthScore=true;
input bool PORTFOLIO_SmartPartialClose=true;
input double PORTFOLIO_PartialClosePercent=30.0;
input bool PORTFOLIO_EnableSoundAlerts=true;

input group "=== نظام TURBO ===" // نظام TURBO
input bool TURBO_Enable=true;
input int TURBO_MinTrend=25;
input double TURBO_LotSize=0.05;
input int TURBO_TP=1200;
input int TURBO_SL=3500;
input double TURBO_MaxRisk=0.8;
input double TURBO_Multiplier=1.6;
input double TURBO_StrongTrendADX=40.0;
input double TURBO_AggressiveMultiplier=2.0;
input bool TURBO_UseMultiTimeframe=true;
input int TURBO_MinConfidence=90;
input int TURBO_WaitSeconds=0;

input group "=== نظام FORCE ===" // نظام FORCE
input bool FORCE_Enable=true;
input int FORCE_AfterLosses=3;
input double FORCE_LotSize=0.05;
input int FORCE_TP=1500;
input int FORCE_SL=3000;
input double FORCE_Multiplier=1.3;
input double FORCE_MaxLot=0.2;
input double FORCE_RecoveryMultiplier=1.4;
input double FORCE_EmergencyLossLevel=100.0;
input bool FORCE_UseSmartRecovery=true;
input int FORCE_MaxRecoveryAttempts=5;
input int FORCE_WaitSeconds=0;

input group "=== نظام المدى ===" // نظام المدى
input bool RANGE_Enable=true;
input double RANGE_MinSize=400.0;
input int RANGE_Periods=60;
input double RANGE_LotSize=0.05;
input int RANGE_ScalpTP=1200;
input int RANGE_ScalpSL=3500;
input double RANGE_ZonePercent=0.25;
input double RANGE_MinQuality=70.0;
input bool RANGE_UseFibonacci=true;
input double RANGE_Fibo382=0.382;
input double RANGE_Fibo618=0.618;
input bool RANGE_RequireRetest=true;
input int RANGE_MinConfirmations=2;
input int RANGE_StartHour=8;
input int RANGE_EndHour=20;
input double RANGE_MinBreakDistance=20.0;
input bool RANGE_UseVolumeFilter=true;
input double RANGE_VolumeMultiplier=1.2;
input int RANGE_WaitSeconds=0;

input group "=== المضاربة السريعة ===" // المضاربة السريعة
input bool SCALP_Enable=true;
input int SCALP_BBPeriod=20;
input double SCALP_BBDeviation=2.0;
input double SCALP_LotSize=0.05;
input int SCALP_QuickTP=50;
input int SCALP_QuickSL=30;
input double SCALP_MinConfidence=70.0;
input int SCALP_MaxDailyTrades=99999;
input bool SCALP_UseSmartExit=true;
input int SCALP_WaitSeconds=0;

input group "=== نظام المؤشرات ===" // نظام المؤشرات
input bool INDICATOR_Enable=true;
input int INDICATOR_MA_FastPeriod=9;
input int INDICATOR_MA_SlowPeriod=21;
input int INDICATOR_RSI_Period=14;
input double INDICATOR_RSI_BuyLevel=50.0;
input double INDICATOR_RSI_SellLevel=50.0;
input double INDICATOR_MinADX=20.0;
input bool INDICATOR_UseM5Confirmation=true;
input double INDICATOR_LotSize=0.0;
input double INDICATOR_StrongSignalMultiplier=1.2;
input int INDICATOR_WaitSeconds=30;
input int INDICATOR_MaxDailyTrades=50;

input group "=== الحماية ===" // الحماية
input bool PROTECT_DrawdownEnable=true;
input double DD_MaxPercent=25.0;
input int DD_StopMinutes=10;
input bool PROTECT_MarginEnable=true;
input double MARGIN_MinLevel=150.0;
input bool PROTECT_VelocityEnable=true;
input double VELOCITY_MaxLossAmount=200.0;
input int VELOCITY_TimeFrame=20;

input group "=== إدارة المخاطر ===" // إدارة المخاطر
input double RISK_Percent=5.0;
input double RISK_MaxDailyLoss=500.0;
input int RISK_MaxTrades=10;
input double RISK_LotSize=0.05;

input group "=== الأهداف ===" // الأهداف
input int TARGET_TakeProfit=1500;
input int TARGET_StopLoss=3000;
input bool TARGET_UseTrailing=true;
input int TARGET_TrailingStart=200;
input int TARGET_TrailingStep=50;

input group "=== إعدادات السوق ===" // إعدادات السوق
input int MARKET_MaxSpread=2000;
input int MARKET_MaxSlippage=1000;
input int MARKET_MinBarsForTrade=15;
input ENUM_TIMEFRAMES MARKET_Timeframe=PERIOD_M1;
input ENUM_TIMEFRAMES MARKET_SecondaryTimeframe=PERIOD_M5;

input group "=== إعدادات متقدمة ===" // إعدادات متقدمة
input int ADVANCED_MagicNumber=302000;
input int ADVANCED_TimerInterval=1;
input bool ADVANCED_EnableLogging=false;
input ENUM_LOG_LEVEL ADVANCED_LogLevel=LOG_INFO;
input bool ADVANCED_UsePrioritySystem=true;

CTrade trade;
CPositionInfo position;
CSymbolInfo symbol_info;
CAccountInfo account;

double g_Point,g_PipValue,g_LastLossAmount,InitialBalance,DailyStartBalance,Bid,Ask;
int g_Digits,mainTrend,ConsecutiveLosses,g_TickIndex,h_MA_Fast,h_MA_Slow,h_RSI,h_ATR,h_ADX,h_MACD,h_BollingerBands,h_MA_Fast_M5,h_MA_Slow_M5,h_RSI_M5,h_ATR_M5,h_ADX_M5;
bool g_SystemInitialized,g_IsGold,g_IsCrypto,g_IndicatorsReady,protectionActive;
datetime LastTradeTime,lastHFTTrade,lastUSTPSignal,LastDailyReset,protectionEndTime,g_LastSessionCheck,g_LastRiskCheck;
string g_CurrentSession="UNKNOWN";
int g_SystemLock=0,g_LogHandle=INVALID_HANDLE;

SafeTickInfo g_TickBuffer[256];
SafeHFTData g_LastHFTData;
RangeData currentRange;
VolumeBoostSignal g_BoostSignal;
TurboSignal g_TurboSignal;
ScalpingSignal g_ScalpingSignal;
ForceRecoveryData g_ForceRecovery;
PortfolioHealth g_PortfolioHealth={100,0,0,100,100,"صحة ممتازة"};
USTPPrediction g_LastUSTPPrediction;
ExternalAPIData g_ExternalData;
RiskMetrics g_CurrentRisk;
SystemActivity g_SystemActivity[10];

int dailyHFTCount,dailyUSTPCount,dailyBoostTrades,dailyTurboTrades,dailyForceTrades,dailyScalpingTrades,dailyIndicatorTrades,successfulRecoveries;
datetime lastTurboTrade=0,lastForceTrade=0,lastRangeTrade=0,lastScalpingTrade=0,lastIndicatorTrade=0,g_LastTickUpdate=0,g_LastFullUpdate=0;
int monitoredTurboDirection=0,monitoredForceDirection=0,monitoredRangeDirection=0,monitoredScalpingDirection=0;
double monitoredTurboConfidence=0,monitoredForceConfidence=0,monitoredRangeConfidence=0,monitoredScalpingConfidence=0;

namespace Logger{
   void Initialize(){
      if(!ADVANCED_EnableLogging)return;
      string filename="GoldenFinale_"+TimeToString(TimeCurrent(),TIME_DATE)+".log";
      g_LogHandle=FileOpen(filename,FILE_WRITE|FILE_CSV|FILE_COMMON);
      if(g_LogHandle!=INVALID_HANDLE){
         FileWrite(g_LogHandle,"Time,Event,System,Type,Lot,Price,Reason,Profit");
         FileFlush(g_LogHandle);
      }
   }
   
   void LogTrade(string system,ENUM_ORDER_TYPE type,double lot,double entry,string reason){
      if(g_LogHandle == INVALID_HANDLE || !ADVANCED_EnableLogging)return;
      string logEntry=StringFormat("%s,TRADE,%s,%s,%.5f,%.5f,%s,0", // Log trade details
         TimeToString(TimeCurrent(),TIME_DATE|TIME_SECONDS),
         system,type==ORDER_TYPE_BUY?"BUY":"SELL",lot,entry,reason);
      FileWrite(g_LogHandle,logEntry);
      FileFlush(g_LogHandle);
   }
   
   void LogError(string function,string error){
      if(g_LogHandle == INVALID_HANDLE)return;
      string entry=StringFormat("%s,ERROR,%s,-,-,-,%s,-", // Log error details
         TimeToString(TimeCurrent(),TIME_DATE|TIME_SECONDS),function,error);
      FileWrite(g_LogHandle,entry);
      Print("❌ ",function,": ",error);
   }
   
   void Close(){
      if(g_LogHandle != INVALID_HANDLE){
         FileClose(g_LogHandle);
         g_LogHandle=INVALID_HANDLE;
      }
   }
}

namespace RiskMonitor{
   const double EMERGENCY_DRAWDOWN=30.0;
   const double WARNING_DRAWDOWN=20.0;
   const double MAX_TOTAL_RISK=10.0;
   
   RiskMetrics CalculateRisk(){
      RiskMetrics risk={0};
      double equity=AccountInfoDouble(ACCOUNT_EQUITY);
      double balance=AccountInfoDouble(ACCOUNT_BALANCE);
      
      risk.currentDrawdown = (balance > 0) ? ((balance-equity)/balance)*100 : 0;
      risk.maxDrawdown=MathMax(risk.maxDrawdown,risk.currentDrawdown);
      risk.marginLevel=AccountInfoDouble(ACCOUNT_MARGIN_LEVEL);
      risk.consecutiveLosses=ConsecutiveLosses;
      
      risk.maxOpenLoss=0;
      for(int i=0;i<PositionsTotal();i++){
         if(position.SelectByIndex(i) && position.Magic()==ADVANCED_MagicNumber){
            double pl=position.Profit()+position.Swap()+position.Commission();
            if(pl<0)risk.maxOpenLoss+=MathAbs(pl);
         }
      }
      
      risk.riskExceeded=(risk.currentDrawdown>WARNING_DRAWDOWN)||(risk.maxOpenLoss>balance*MAX_TOTAL_RISK/100);
      
      if(risk.currentDrawdown>EMERGENCY_DRAWDOWN){
         EmergencyCloseAll("Emergency drawdown "+DoubleToString(risk.currentDrawdown,1)+"%");
      }
      
      return risk;
   }
   
   bool CanOpenNewTrade(){
      if(!g_SystemInitialized) return false;
      g_CurrentRisk=CalculateRisk();
      
      if(g_CurrentRisk.riskExceeded){
         if(ADVANCED_EnableLogging)Logger::LogError("RiskMonitor","Risk exceeded - blocking new trades");
         return false;
      }
      
      double freeMargin=AccountInfoDouble(ACCOUNT_MARGIN_FREE);
      double balance=AccountInfoDouble(ACCOUNT_BALANCE);
      if(freeMargin<balance*0.2)return false;
      
      return true;
   }
   
   void EmergencyCloseAll(string reason){
      Print("🚨 EMERGENCY CLOSE: ",reason);
      for(int i=PositionsTotal()-1;i>=0;i--){
         if(position.SelectByIndex(i) && position.Magic()==ADVANCED_MagicNumber){
            trade.PositionClose(position.Ticket());
         }
      }
   }
}

namespace SystemLock{
   bool TryLock(){ // Try to acquire the system lock
      if(g_SystemLock > 0) return false;
      g_SystemLock++;
      return true;
   } // Added closing brace
   
   void Unlock(){
      if(g_SystemLock>0)g_SystemLock--;
   }
   
   bool IsLocked(){
      return g_SystemLock>0;
   }
}

namespace SmartPortfolio{
   datetime last_check_time=0;
   double total_closed_profit=0;
   int total_trades_closed=0;
   
   struct InternalStatistics{
      int total_system_trades,exceptional_trades_count,ultra_balance_trades_count,trades_by_type[11];
      double profit_by_type[11];
      string type_names[11];
      datetime last_update;
      
      void Init(){
         total_system_trades=exceptional_trades_count=ultra_balance_trades_count=0; // Initialize counters
         for(int i=0;i<11;i++){trades_by_type[i]=0;profit_by_type[i]=0.0;} // Added missing semicolon
         type_names[0]="ULTRA_BALANCE";type_names[1]="ULTRA_EXCEPTIONAL";type_names[2]="BOOST";type_names[3]="HFT";type_names[4]="TURBO";
         type_names[5]="FORCE";type_names[6]="RANGE";type_names[7]="USTP";type_names[8]="INDICATOR";type_names[9]="SCALP";type_names[10]="AI";
         last_update=TimeCurrent();
      }
      
      int GetTypeIndex(string comment){
         if(StringFind(comment,"ULTRA_BALANCE")>=0)return 0;
         else if(StringFind(comment,"ULTRA_EXCEPTIONAL")>=0)return 1;
         else if(StringFind(comment,"BOOST")>=0)return 2;
         else if(StringFind(comment,"HFT")>=0)return 3;
         else if(StringFind(comment,"TURBO")>=0)return 4;
         else if(StringFind(comment,"FORCE")>=0)return 5;
         else if(StringFind(comment,"RANGE")>=0)return 6;
         else if(StringFind(comment,"USTP")>=0)return 7;
         else if(StringFind(comment,"INDICATOR")>=0)return 8;
         else if(StringFind(comment,"SCALP")>=0)return 9;
         else if(StringFind(comment,"AI")>=0)return 10;
         else return 8;
      }
      
      void UpdateOnClose(string comment,double profit){
         int index=GetTypeIndex(comment);
         if(index>=0 && index<11){
            if(trades_by_type[index]>0){trades_by_type[index]--;profit_by_type[index]+=profit;}
            if(total_system_trades>0)total_system_trades--;
            if(index==0&&ultra_balance_trades_count>0)ultra_balance_trades_count--;
            else if(index==1&&exceptional_trades_count>0)exceptional_trades_count--;
            last_update=TimeCurrent();
         }
      }
      
      void RefreshFromOpenPositions(){
         total_system_trades=exceptional_trades_count=ultra_balance_trades_count=0;
         for(int i=0;i<11;i++)trades_by_type[i]=0;
         for(int i=0;i<PositionsTotal();i++){ // Iterate through open positions
            if(position.SelectByIndex(i)){
               if(position.Magic()==ADVANCED_MagicNumber&&position.Symbol()==_Symbol){
                  string comment=position.Comment();
                  int index=GetTypeIndex(comment);
                  trades_by_type[index]++;total_system_trades++;
                  if(index==0)ultra_balance_trades_count++;
                  else if(index==1)exceptional_trades_count++;
               }
            }
         }
         last_update=TimeCurrent();
      }
   }internal_stats;
   
   struct SafePortfolioMetrics{
      int total_positions,buy_positions,sell_positions,profitable_positions,losing_positions;
      double total_pnl,total_profit,total_loss,best_profit_position,worst_loss_position;
      ulong best_profit_ticket,worst_loss_ticket;
      bool should_close_all,should_close_partial,data_valid;
      string action_reason;
      
      void Init(){
         total_positions=buy_positions=sell_positions=profitable_positions=losing_positions=0;
         total_pnl=total_profit=total_loss=best_profit_position=worst_loss_position=0.0;
         best_profit_ticket=worst_loss_ticket=0;
         should_close_all=should_close_partial=data_valid=false;
         action_reason="";
      }
   };
   
   void ManageSafePortfolio(){
      if(!PORTFOLIO_Enable || !g_SystemInitialized)return;
      if(TimeCurrent()-last_check_time<PORTFOLIO_CheckInterval)return; // Check interval
      last_check_time=TimeCurrent();
      internal_stats.RefreshFromOpenPositions();
      SafePortfolioMetrics metrics; // Initialize metrics
      metrics.Init();
      metrics=AnalyzeSafeMetrics();
      if(!metrics.data_valid) return;
      if(metrics.should_close_all) SafeCloseAllPositions(metrics.action_reason);
      else if(metrics.should_close_partial){ // Added missing semicolon
         if(PORTFOLIO_SmartPartialClose)SmartPartialClose(metrics);
         else SafeClosePartialPositions(metrics);
      }
   }
   
   SafePortfolioMetrics AnalyzeSafeMetrics(){
      SafePortfolioMetrics metrics;
      metrics.Init(); // Initialize metrics
      if(!TerminalInfoInteger(TERMINAL_CONNECTED)){ // Added missing semicolon
         if(ADVANCED_EnableLogging)Print("❌ لا يوجد اتصال بالخادم");
         return metrics;
      }
      bool has_positions=false;
      for(int i=0;i<PositionsTotal();i++){
         if(!position.SelectByIndex(i))continue;
         if(position.Magic()!=ADVANCED_MagicNumber || position.Symbol()!=_Symbol)continue;
         double pnl=position.Profit()+position.Swap()+position.Commission();
         if(MathAbs(pnl)>10000){
            if(ADVANCED_EnableLogging)Print("⚠️ تحذير: قيمة شاذة في الصفقة ",position.Ticket()," PnL: ",DoubleToString(pnl,2));
            continue;
         }
         has_positions=true;metrics.total_positions++;metrics.total_pnl+=pnl; // Update position counts and PnL
         if(position.PositionType()==POSITION_TYPE_BUY)metrics.buy_positions++;
         else metrics.sell_positions++;
         if(pnl>0){
            metrics.total_profit+=pnl;metrics.profitable_positions++; // Update profit metrics
            if(pnl>metrics.best_profit_position){metrics.best_profit_position=pnl;metrics.best_profit_ticket=position.Ticket();} // Added missing semicolon
         }else{
            metrics.total_loss+=MathAbs(pnl);metrics.losing_positions++; // Update loss metrics
            if(pnl<metrics.worst_loss_position){metrics.worst_loss_position=pnl;metrics.worst_loss_ticket=position.Ticket();} // Added missing semicolon
         }
      }
      if(!has_positions){metrics.data_valid=false;return metrics;} // Added missing semicolon
      metrics.data_valid=true; // Added missing semicolon
      if(metrics.total_pnl>=PORTFOLIO_TargetProfit){
         metrics.should_close_all=true;
         metrics.action_reason=StringFormat("تحقيق هدف الربح $%.2f",PORTFOLIO_TargetProfit);
      }else if(metrics.profitable_positions>0){
         if(metrics.losing_positions>0&&metrics.total_pnl>0){
            if(metrics.total_profit>metrics.total_loss*1.5){
               metrics.should_close_partial=true;
               metrics.action_reason="إغلاق جزئي ذكي - الأرباح تفوق الخسائر";
            }
         }else if(metrics.best_profit_position>=PORTFOLIO_MinProfitPerTrade){
            metrics.should_close_partial=true;
            metrics.action_reason=StringFormat("صفقة رابحة كبيرة $%.2f",metrics.best_profit_position);
         }
      }
      return metrics;
   }
   
   void SafeCloseAllPositions(string reason){
      int closed=0,failed=0;
      double total_profit=0;
      int closed_by_type[11]={0};
      int initial_count=PositionsTotal(); // Get initial position count
      if(ADVANCED_EnableLogging){
         Print("════════════════════════════════════════");
         Print("📊 بدء إغلاق شامل: ",reason);
         Print("📈 عدد الصفقات المفتوحة: ",initial_count);
      }
      for(int i=initial_count-1;i>=0;i--){
         if(i>=PositionsTotal())continue; // Added missing semicolon
         if(!position.SelectByIndex(i))continue;
         if(position.Magic()!=ADVANCED_MagicNumber || position.Symbol()!=_Symbol)continue;
         string comment=position.Comment();
         ulong ticket=position.Ticket();
         double profit=position.Profit()+position.Swap()+position.Commission();
         ResetLastError(); // Reset error before closing position
         if(trade.PositionClose(ticket)){ // Added missing semicolon
            if(trade.ResultRetcode()==TRADE_RETCODE_DONE){
               closed++;total_trades_closed++;total_profit+=profit;
               int type_index=internal_stats.GetTypeIndex(comment);
               closed_by_type[type_index]++;
               internal_stats.UpdateOnClose(comment,profit);
               if(ADVANCED_EnableLogging)Print("✅ تم إغلاق الصفقة ",ticket," | الربح: $",DoubleToString(profit,2)," | النوع: ",comment);
            }
         }else{
            failed++;
            if(ADVANCED_EnableLogging)Print("❌ فشل إغلاق الصفقة ",ticket," | الخطأ: ",trade.ResultRetcode()," - ",trade.ResultRetcodeDescription());
         }
      }
      if(closed>0){ // If positions were closed successfully
         total_closed_profit+=total_profit; // Added missing semicolon
         Print("════════════════════════════════════════");
         Print("✅ تم إغلاق ",closed," صفقات بنجاح");
         Print("💰 إجمالي الربح: $",DoubleToString(total_profit,2));
         for(int i=0;i<11;i++){
            if(closed_by_type[i]>0)Print("   └─ ",internal_stats.type_names[i],": ",closed_by_type[i]," صفقات");
         }
         if(failed>0)Print("⚠️ فشل إغلاق ",failed," صفقات");
         Print("════════════════════════════════════════");
         if(PORTFOLIO_EnableSoundAlerts)PlaySound("ok.wav");
         Alert("📊 المحفظة الذكية: إغلاق شامل - ربح $",DoubleToString(total_profit,2)," من ",closed," صفقات");
      }
   }
   
   void SafeClosePartialPositions(SafePortfolioMetrics &metrics){
      if(metrics.total_positions<=0)return; // Added missing semicolon
      int positions_to_close=(int)(metrics.total_positions*PORTFOLIO_PartialClosePercent/100.0); // Calculate number of positions to close
      positions_to_close=MathMax(1,MathMin(positions_to_close,metrics.losing_positions+1));
      int closed=0;
      if(ADVANCED_EnableLogging)Print("📊 بدء إغلاق جزئي بسيط - هدف: ",positions_to_close," صفقات");
      
      while(closed<positions_to_close){
         bool foundPosition=false;
         int currentTotal=PositionsTotal();
         
         for(int i=currentTotal-1;i>=0;i--){
            if(!position.SelectByIndex(i))continue;
            if(position.Magic()!=ADVANCED_MagicNumber || position.Symbol()!=_Symbol)continue;
            double pnl=position.Profit()+position.Swap()+position.Commission();
            if(pnl<-1.0){
               string comment=position.Comment();
               ulong ticket=position.Ticket();
               ResetLastError(); // Reset error before closing position
               if(trade.PositionClose(ticket)){
                  if(trade.ResultRetcode()==TRADE_RETCODE_DONE){
                     closed++;total_trades_closed++; // Added missing semicolon
                     internal_stats.UpdateOnClose(comment,pnl);
                     if(ADVANCED_EnableLogging)Print("✅ إغلاق صفقة خاسرة ",ticket," | الخسارة: $",DoubleToString(MathAbs(pnl),2));
                     foundPosition=true;
                     break;
                  }
               }
            }
         } // End of inner loop
         // Added missing semicolon
         if(!foundPosition)break;
      }
      if(closed>0)Print("📊 تم إغلاق جزئي لـ ",closed," صفقات خاسرة");
   }
   
   void SmartPartialClose(SafePortfolioMetrics &metrics){
      int closed=0;
      double closed_profit=0;
      if(ADVANCED_EnableLogging)Print("🧠 بدء إغلاق جزئي ذكي");
      
      if(metrics.best_profit_ticket>0&&metrics.best_profit_position>=PORTFOLIO_MinProfitPerTrade){
         if(position.SelectByTicket(metrics.best_profit_ticket)){ // Select the best profitable position
            string comment=position.Comment(); // Added missing semicolon
            double profit=position.Profit()+position.Swap()+position.Commission();
            ResetLastError();
            if(trade.PositionClose(metrics.best_profit_ticket)){
               if(trade.ResultRetcode()==TRADE_RETCODE_DONE){
                  closed++;closed_profit+=profit;total_trades_closed++;total_closed_profit+=profit;
                  internal_stats.UpdateOnClose(comment,profit);
                  Print("💰 تم إغلاق أفضل صفقة رابحة $",DoubleToString(profit,2)," من ",comment!=""?comment:"نظام عادي");
               }
            }
         }
      }
      
      if(PORTFOLIO_PartialClosePercent>0&&metrics.profitable_positions>1){ // If partial close is enabled and there are multiple profitable positions
         int positions_to_close=(int)(metrics.profitable_positions*PORTFOLIO_PartialClosePercent/100.0);
         positions_to_close=MathMax(1,positions_to_close);
         int target_close=closed+positions_to_close;
         
         while(closed<target_close){
            bool foundPosition=false;
            int currentTotal=PositionsTotal();
            
            for(int i=currentTotal-1;i>=0;i--){
               if(!position.SelectByIndex(i))continue;
               if(position.Magic()!=ADVANCED_MagicNumber || position.Symbol()!=_Symbol)continue;
               double pnl=position.Profit()+position.Swap()+position.Commission();
               if(pnl>=PORTFOLIO_MinProfitPerTrade*0.5){
                  string comment=position.Comment();
                  ulong ticket=position.Ticket();
                  ResetLastError(); // Reset error before closing position
                  if(trade.PositionClose(ticket)){
                     if(trade.ResultRetcode()==TRADE_RETCODE_DONE){
                        closed++;closed_profit+=pnl;total_trades_closed++;total_closed_profit+=pnl; // Added missing semicolon
                        internal_stats.UpdateOnClose(comment,pnl);
                        foundPosition=true;
                        break;
                     }
                  }
               }
            } // End of inner loop
            
            if(!foundPosition)break; // Added missing semicolon
         }
      }
      
      if(closed>0){
         Print("═══════════════════════════════════════");
         Print("🧠 إغلاق جزئي ذكي: ",closed," صفقات");
         Print("💰 الربح المحقق: $",DoubleToString(closed_profit,2));
         Print("═══════════════════════════════════════");
         if(PORTFOLIO_EnableSoundAlerts)PlaySound("tick.wav");
         Alert("✅ إغلاق جزئي ذكي شامل: $",DoubleToString(closed_profit,2));
      }
   }
   
   string GetMetrics(){
      internal_stats.RefreshFromOpenPositions(); // Refresh internal statistics
      double net_pnl=0;
      int count=0;
      for(int i=0;i<PositionsTotal();i++){
         if(position.SelectByIndex(i)){
            if(position.Magic()!=ADVANCED_MagicNumber || position.Symbol()!=_Symbol)continue;
            net_pnl+=position.Profit()+position.Swap()+position.Commission();
            count++;
         }
      }
      string metrics=StringFormat("صافي P/L: $%.2f | العدد: %d",net_pnl,count);
      bool has_special_types=false;
      for(int i=0;i<11;i++){
         if(internal_stats.trades_by_type[i]>0){
            if(!has_special_types){metrics+=" |";has_special_types=true;}
            metrics+=StringFormat(" %s: %d",internal_stats.type_names[i],internal_stats.trades_by_type[i]);
         }
      }
      if(total_trades_closed>0)metrics+=StringFormat(" | مغلقة: %d ($%.2f)",total_trades_closed,total_closed_profit);
      return metrics;
   }
   
   void ResetStatistics(){ // Added return type
      total_closed_profit=0;total_trades_closed=0; // Reset all statistics
      internal_stats.Init();internal_stats.RefreshFromOpenPositions();
      Print("📊 تم إعادة تعيين إحصائيات المحفظة الذكية");
   }
   
   bool Initialize(){
      if(PORTFOLIO_TargetProfit<=0){Print("❌ خطأ: هدف الربح يجب أن يكون أكبر من صفر");return false;}
      if(PORTFOLIO_MinProfitPerTrade<0){Print("❌ خطأ: الحد الأدنى للربح لا يمكن أن يكون سالباً");return false;} // Added missing semicolon
      if(PORTFOLIO_PartialClosePercent<0||PORTFOLIO_PartialClosePercent>100){Print("❌ خطأ: نسبة الإغلاق الجزئي يجب أن تكون بين 0 و 100");return false;}
      internal_stats.Init();internal_stats.RefreshFromOpenPositions(); // Initialize and refresh internal statistics
      Print("════════════════════════════════════════");
      Print("✅ تم تهيئة نظام المحفظة الذكية الموحد");
      Print("🔧 الرقم السحري: ",ADVANCED_MagicNumber);
      Print("📊 الرمز: ",_Symbol);
      Print("💰 هدف الربح: $",PORTFOLIO_TargetProfit);
      Print("⏱️ فترة الفحص: ",PORTFOLIO_CheckInterval," ثانية");
      Print("════════════════════════════════════════");
      return true;
   }
}

class AITradingSystem{
private:
   static int analysisLock;
   static bool fastAnalysisInProgress,deepAnalysisInProgress;
   static datetime lastSuccessfulHaikuCall,lastSuccessfulSonnetCall;
   
   static bool TryLockAnalysis(){ // Added return type
      if(analysisLock>0)return false; // Check if analysis is already locked
      analysisLock++;
      return true;
   }
   
   static void UnlockAnalysis(){
      if(analysisLock>0)analysisLock--;
   }
   
public:
   static string apiKey;
   static int dailyCalls,haikuCallCount,sonnetCallCount,sessionWins,sessionLosses,newsCount;
   static datetime lastFastAnalysis,lastDeepAnalysis,dailyReset;
   static NewsEvent upcomingNews[10];
   static AIAnalysis currentAnalysis,previousAnalysis;
   static EmergencyAction emergencyStatus;
   static DynamicSettings dynamicSettings;
   static SessionTiming sessionTiming;
   static double sessionProfitLoss;static double maxDrawdownToday;static double bestStrategy;
   
   static string GetAPIKey(){return AI_ExternalAPI_Key!=""?AI_ExternalAPI_Key:AI_APIKey;}
   
   static void InitializeSessionTimings(){
      sessionTiming.asianHaikuSeconds=20;sessionTiming.asianSonnetMinutes=3; // Initialize session timings
      sessionTiming.europeanHaikuSeconds=15;sessionTiming.europeanSonnetMinutes=2;
      sessionTiming.americanHaikuSeconds=15;sessionTiming.americanSonnetMinutes=2;
      sessionTiming.emergencySonnetOnly=false;
   }
   
   static string GetAppropriateModel(bool isEmergency=false){
      if(isEmergency||sessionTiming.emergencySonnetOnly)return "claude-3-5-sonnet-20241022";
      if(!IsHighImpactNewsToday()&&MathRand()%100<80)return "claude-3-5-haiku-20241022";
      return isEmergency?"claude-3-5-sonnet-20241022":"claude-3-5-haiku-20241022";
   }
   
   static bool IsHighImpactNewsToday(){
      if(!NEWS_Enable)return false; // Added missing semicolon
      datetime today=StringToTime(TimeToString(TimeCurrent(),TIME_DATE)),tomorrow=today+86400; // Get today's and tomorrow's date
      for(int i=0;i<newsCount;i++)if(upcomingNews[i].impact==NEWS_HIGH&&upcomingNews[i].time>=today&&upcomingNews[i].time<tomorrow)return true;
      return false;
   }
   
   static void InitializeDynamicSettings(){
      dynamicSettings.originalMaxTrades=RISK_MaxTrades;dynamicSettings.currentMaxTrades=RISK_MaxTrades;
      dynamicSettings.originalPortfolioTarget=PORTFOLIO_TargetProfit;dynamicSettings.currentPortfolioTarget=PORTFOLIO_TargetProfit;
      dynamicSettings.protectionOverridden=false;
   }
   
   static void MonitorAndFixErrors(){
      if(!AI_MonitorJournal)return; // If journal monitoring is disabled, return
      static datetime lastCheck=0;
      if(TimeCurrent()-lastCheck<5)return;
      lastCheck=TimeCurrent();
      int error=GetLastError();
      if(error==10014){Print("🔧 orioto.ai: اكتشاف خطأ حجم غير صالح - إصلاح تلقائي");FixVolumeError();}
   }
   
   static void FixVolumeError(){
      if(!AI_AutoFixVolume)return; // If auto fix volume is disabled, return
      double minLot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN),maxLot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX),lotStep=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
      Print("🔍 orioto.ai Volume Fix:");Print("Min Lot: ",minLot);Print("Max Lot: ",maxLot);Print("Lot Step: ",lotStep);
      if(dynamicSettings.currentMaxTrades>0){
         double suggestedLot=minLot;
         while(suggestedLot<0.1&&suggestedLot+lotStep<=maxLot)suggestedLot+=lotStep;
         Print("✅ Suggested lot size: ",suggestedLot);
      }
   }
   
   static void FastMarketScan(){
      if(AI_Mode==AI_OFF)return; // If AI is off, return
      if(!TryLockAnalysis())return;
      fastAnalysisInProgress=true;
      MonitorAndFixErrors();
      if(AI_UseExternalAPIs)UpdateExternalData();
      string prompt=BuildEnhancedFastPrompt();
      bool useHaiku=AI_Mode==AI_HAIKU||(AI_Mode==AI_ADAPTIVE&&ShouldUseHaikuFixed());
      string model=useHaiku?"claude-3-5-haiku-20241022":"claude-3-5-sonnet-20241022";
      int nextAnalysis=GetFastAnalysisInterval();
      Print("🤖 orioto.ai Fast Analysis (",model,") - Next in ",nextAnalysis,"s");
      string response=CallOriotoAPIWithRetry(prompt,true,useHaiku);
      if(AI_DirectTrading&&response!="")ExecuteAIDirectTrades(response);
      lastFastAnalysis=TimeCurrent();
      fastAnalysisInProgress=false;
      UnlockAnalysis();
   }
   
   static string CallOriotoAPIWithRetry(string prompt,bool fast,bool useHaiku=false,int maxRetries=3){
      for(int i=0;i<maxRetries;i++){ // Loop for retries
         string response=CallOriotoAPI(prompt,fast,useHaiku);
         if(response!=""&&ValidateAIResponse(response))return response;
         if(i<maxRetries-1)Sleep(1000*(i+1));
      }
      return LocalAnalysis(prompt,fast);
   }
   
   static bool ValidateAIResponse(string response){ // Validate AI response
      if(StringLen(response)<5)return false; // Added missing semicolon
      if(StringFind(response,"ERROR")>=0)return false;
      if(StringFind(response,"BUY")<0&&StringFind(response,"SELL")<0&&StringFind(response,"WAIT")<0&&StringFind(response,"CLOSE")<0)return false;
      return true;
   }
   
   static bool ShouldUseHaikuFixed(){
      if(emergencyStatus.required||g_PortfolioHealth.score<30||ConsecutiveLosses>=5)return false; // Conditions for not using Haiku
      if(g_CurrentSession=="ASIAN")return true;
      if(ConsecutiveLosses<3&&g_PortfolioHealth.score>50)return true;
      return false;
   }
   
   static int GetFastAnalysisInterval(){
      if(sessionTiming.emergencySonnetOnly)return MathMax(10,AI_FastAnalysisSeconds); // Added missing semicolon
      if(g_CurrentSession=="ASIAN")return MathMax(sessionTiming.asianHaikuSeconds,AI_FastAnalysisSeconds); // Get analysis interval based on session
      if(g_CurrentSession=="EUROPEAN"||g_CurrentSession=="EUROPEAN+AMERICAN")return MathMax(sessionTiming.europeanHaikuSeconds,AI_FastAnalysisSeconds);
      if(g_CurrentSession=="AMERICAN")return MathMax(sessionTiming.americanHaikuSeconds,AI_FastAnalysisSeconds);
      return AI_FastAnalysisSeconds;
   }
   
   static string BuildEnhancedFastPrompt(){
      string prompt="[FAST_M1M5] "+_Symbol+" "+DoubleToString(Bid,_Digits)+"/"+DoubleToString(Ask,_Digits)+" S:"+g_CurrentSession+" ";
      prompt+="M1:"+GetM1Analysis()+" M5:"+GetM5Analysis()+" P:"+IntegerToString(PositionsTotal())+" PL:$"+DoubleToString(GetCurrentPL(),0)+" H:"+DoubleToString(g_PortfolioHealth.score,0)+"% "; // Add market and portfolio data
      prompt+="MKT:"+GetEnhancedMarketStateCode()+" VOL:"+GetVolatilityCode()+" MOM:"+GetMomentumCode()+" ";
      if(AI_UseExternalAPIs&&g_ExternalData.dataValid)prompt+="EXT:"+g_ExternalData.trend+"/"+g_ExternalData.sentiment+" ";
      if(g_TurboSignal.active)prompt+="T ";if(g_BoostSignal.active)prompt+="B ";if(g_ScalpingSignal.active)prompt+="S ";
      if(ConsecutiveLosses>=3)prompt+="L"+IntegerToString(ConsecutiveLosses)+" ";
      if(protectionActive)prompt+="PROT ";
      prompt+="\nACT?";
      return prompt;
   }
   
   static string GetM1Analysis(){
      double ma_fast[],ma_slow[];
      if(CopyBuffer(h_MA_Fast,0,0,5,ma_fast)==5 && CopyBuffer(h_MA_Slow,0,0,5,ma_slow)==5){ // Copy MA data
         double trend=(ma_fast[4]-ma_slow[4])/g_Point,momentum=(ma_fast[4]-ma_fast[0])/g_Point;
         if(trend>30&&momentum>10)return "SU";if(trend>10&&momentum>0)return "U";
         if(trend<-30&&momentum<-10)return "SD";if(trend<-10&&momentum<0)return "D";
      }
      return "N";
   }
   
   static string GetM5Analysis(){
      double ma_fast[],ma_slow[];
      if(CopyBuffer(h_MA_Fast_M5,0,0,5,ma_fast)==5 && CopyBuffer(h_MA_Slow_M5,0,0,5,ma_slow)==5){
         double trend=(ma_fast[4]-ma_slow[4])/g_Point;
         if(trend>50)return "SU";if(trend>20)return "U";
         if(trend<-50)return "SD";if(trend<-20)return "D";
      }
      return "N";
   }
   
   static string GetEnhancedMarketStateCode(){
      double adx=GetCurrentADX();string m1State=GetM1Analysis(),m5State=GetM5Analysis();
      if(m1State==m5State){ // Added missing semicolon
         if(m1State=="SU"&&adx>35)return "VSU";if(m1State=="SD"&&adx>35)return "VSD";
         return m1State;
      }
      if((m1State=="SU"&&m5State=="SD")||(m1State=="SD"&&m5State=="SU"))return "CH";
      return GetMarketStateCode();
   }
   
   static string GetMomentumCode(){
      double momentum1=GetMomentum(1),momentum5=GetMomentum(5);
      if(momentum1>50&&momentum5>30)return "VS";if(momentum1>20&&momentum5>10)return "S";
      if(momentum1<-50&&momentum5<-30)return "VW";if(momentum1<-20&&momentum5<-10)return "W";
      return "N";
   }
   
   static string GetMarketStateCode(){
      double adx=GetCurrentADX(),ma_fast[],ma_slow[];
      if(CopyBuffer(h_MA_Fast,0,0,1,ma_fast)==1 && CopyBuffer(h_MA_Slow,0,0,1,ma_slow)==1){
         double diff=(ma_fast[0]-ma_slow[0])/g_Point;
         if(adx>40){if(diff>50)return "SU";if(diff<-50)return "SD";}
         else if(adx>25){if(diff>20)return "U";if(diff<-20)return "D";}
      }
      return "N";
   }
   
   static string GetVolatilityCode(){
      string vol=GetVolatilityLevel();
      if(vol=="EXTREME")return "X";if(vol=="HIGH")return "H";if(vol=="LOW")return "L";
      return "N";
   }
   
   static void UpdateExternalData(){
      if(!AI_UseExternalAPIs || AI_ExternalAPI_Key=="")return;
      static datetime lastUpdate=0;
      if(TimeCurrent()-lastUpdate<30)return;
      string apiUrl="https://api.metals-api.com/v1/latest?access_key="+AI_ExternalAPI_Key+"&symbols=XAU";
      char post[],result[];string headers="Accept: application/json",resultHeaders;
      ArrayResize(post,0);
      int res=WebRequest("GET",apiUrl,headers,5000,post,result,resultHeaders);
      if(res==200){string data=CharArrayToString(result,0,WHOLE_ARRAY,CP_UTF8);ParseExternalData(data);}
      lastUpdate=TimeCurrent();
   }
   
   static void ParseExternalData(string jsonData){
      g_ExternalData.lastUpdate=TimeCurrent();g_ExternalData.dataValid=true; // Added missing semicolon
      if(StringFind(jsonData,"trend")>=0){
         if(StringFind(jsonData,"bullish")>=0)g_ExternalData.trend="UP";
         else if(StringFind(jsonData,"bearish")>=0)g_ExternalData.trend="DOWN";
         else g_ExternalData.trend="NEUTRAL";
      }
      if(StringFind(jsonData,"sentiment")>=0){
         if(StringFind(jsonData,"positive")>=0)g_ExternalData.sentiment="POS";
         else if(StringFind(jsonData,"negative")>=0)g_ExternalData.sentiment="NEG";
         else g_ExternalData.sentiment="NEUTRAL";
      }
   }
   
   static void ExecuteAIDirectTrades(string response){
      if(SystemLock::IsLocked())return; // Added missing semicolon
      
      string upperResponse;
      upperResponse=response;
      StringToUpper(upperResponse);
      
      if(StringLen(upperResponse)<3){
         if(ADVANCED_EnableLogging)Logger::LogError("ExecuteAIDirectTrades","Response too short");
         return;
      }
      
      if(StringFind(upperResponse,"SCALP_MULTIPLE")>=0){
         int tradesOpened=0; // Added missing semicolon
         int maxTrades=MathMin(10,AI_MaxPositions-PositionsTotal());
         
         for(int i=0;i<maxTrades;i++){
            bool shouldOpenBuy=(StringFind(upperResponse,"BUY_M1")>=0);
            bool shouldOpenSell=(StringFind(upperResponse,"SELL_M1")>=0);
            
            if(shouldOpenBuy){
               ExecuteScalpTrade(ORDER_TYPE_BUY,"AI_SCALP_M1_"+IntegerToString(i+1));
               tradesOpened++;
               Sleep(100);
            } // Added missing semicolon
            if(shouldOpenSell){
               ExecuteScalpTrade(ORDER_TYPE_SELL,"AI_SCALP_M1_"+IntegerToString(i+1));
               tradesOpened++;
               Sleep(100);
            }
            
            if(PositionsTotal()>=AI_MaxPositions)break;
         }
         if(tradesOpened>0)Print("🤖 orioto.ai: فتح ",tradesOpened," صفقات سكالبينج M1");
      } // Added missing semicolon
      else if(StringFind(upperResponse,"M5_TREND_BUY")>=0){
         if(PositionsTotal()<AI_MaxPositions)ExecuteM5Trade(ORDER_TYPE_BUY,"AI_M5_TREND");
      } // Added missing semicolon
      else if(StringFind(upperResponse,"M5_TREND_SELL")>=0){
         if(PositionsTotal()<AI_MaxPositions)ExecuteM5Trade(ORDER_TYPE_SELL,"AI_M5_TREND");
      } // Added missing semicolon
      else if(StringFind(upperResponse,"BUY")>=0&&PositionsTotal()<AI_MaxPositions){
         if(StringFind(upperResponse,"BUY")==0||StringFind(upperResponse," BUY")>=0||StringFind(upperResponse,"\nBUY")>=0)
            ExecuteAITrade(ORDER_TYPE_BUY,"AI_DIRECT_BUY",response); // Added missing semicolon
      }
      else if(StringFind(upperResponse,"SELL")>=0&&PositionsTotal()<AI_MaxPositions){
         if(StringFind(upperResponse,"SELL")==0||StringFind(upperResponse," SELL")>=0||StringFind(upperResponse,"\nSELL")>=0)
            ExecuteAITrade(ORDER_TYPE_SELL,"AI_DIRECT_SELL",response);
      }
      else if(StringFind(upperResponse,"CLOSE_ALL")>=0)CloseAllAIPositions("orioto.ai: قرار إغلاق شامل");
      else if(StringFind(upperResponse,"CLOSE_LOSING")>=0)CloseLosingPositions();
      else if(StringFind(upperResponse,"CLOSE_WINNING")>=0)CloseWinningPositions();
      
      if(StringFind(upperResponse,"ACTIVATE_TURBO")>=0||StringFind(upperResponse,"ACT_T")>=0){
         g_TurboSignal.active=true;
         g_TurboSignal.direction=StringFind(upperResponse,"TURBO_BUY")>=0?1:-1;
         g_TurboSignal.confidence=95;
      }
      if(StringFind(upperResponse,"ACTIVATE_BOOST")>=0||StringFind(upperResponse,"ACT_B")>=0){
         g_BoostSignal.active=true;
         g_BoostSignal.direction=StringFind(upperResponse,"BOOST_BUY")>=0?1:-1;
         g_BoostSignal.confidence=95;
      }
      if(StringFind(upperResponse,"FORCE_ULTRA_BALANCE")>=0||StringFind(upperResponse,"UB:Y")>=0){
         UltraBalance::ForceIntervention();
      }
   }
   
   static void ExecuteM5Trade(ENUM_ORDER_TYPE type,string comment){
      if(!RiskMonitor::CanOpenNewTrade())return;
      double lot=CalculateLotSize()*1.2;
      int tp=TARGET_TakeProfit;
      int sl=TARGET_StopLoss;
      double price=type==ORDER_TYPE_BUY?Ask:Bid,tp_price=type==ORDER_TYPE_BUY?price+tp*g_Point:price-tp*g_Point,sl_price=type==ORDER_TYPE_BUY?price-sl*g_Point:price+sl*g_Point;
      trade.SetExpertMagicNumber(ADVANCED_MagicNumber);trade.SetDeviationInPoints(20);
      if(trade.PositionOpen(_Symbol,type,lot,price,sl_price,tp_price,comment)){
         Print("📊 orioto.ai M5: ",comment);
         Logger::LogTrade("AI_M5",type,lot,price,comment);
      }
   }
   
   static void ExecuteAITrade(ENUM_ORDER_TYPE type,string comment,string aiResponse){
      if(!RiskMonitor::CanOpenNewTrade())return;
      double lot=ExtractLotFromResponse(aiResponse);
      if(lot<=0)lot=CalculateLotSize();
      if(AI_AutoAdjustLots){double marketConditionMultiplier=GetMarketConditionMultiplier();lot*=marketConditionMultiplier;}
      lot=MathMax(lot,RISK_LotSize>0?RISK_LotSize:0.05);
      if(protectionActive&&AI_FullControl)OverrideProtection("orioto.ai: ظروف ممتازة للتداول");
      double price=type==ORDER_TYPE_BUY?Ask:Bid,tp_price=type==ORDER_TYPE_BUY?price+TARGET_TakeProfit*g_Point:price-TARGET_TakeProfit*g_Point,sl_price=type==ORDER_TYPE_BUY?price-TARGET_StopLoss*g_Point:price+TARGET_StopLoss*g_Point;
      trade.SetExpertMagicNumber(ADVANCED_MagicNumber);trade.SetDeviationInPoints(30);
      if(trade.PositionOpen(_Symbol,type,lot,price,sl_price,tp_price,comment)){
         Print("✅ orioto.ai: ",comment," Lot=",DoubleToString(lot,2));
         Logger::LogTrade("AI_Direct",type,lot,price,comment);
         if(StringFind(comment,"HAIKU")>=0)haikuCallCount++;else sonnetCallCount++;
      }
   }
   
   static void ExecuteScalpTrade(ENUM_ORDER_TYPE type,string comment){
      if(!RiskMonitor::CanOpenNewTrade())return;
      double lot=SCALP_LotSize>0?SCALP_LotSize:CalculateLotSize()*0.8;
      int tp=SCALP_QuickTP;
      int sl=SCALP_QuickSL;
      double price=type==ORDER_TYPE_BUY?Ask:Bid,tp_price=type==ORDER_TYPE_BUY?price+tp*g_Point:price-tp*g_Point,sl_price=type==ORDER_TYPE_BUY?price-sl*g_Point:price+sl*g_Point;
      trade.SetExpertMagicNumber(ADVANCED_MagicNumber);trade.SetDeviationInPoints(10);
      if(trade.PositionOpen(_Symbol,type,lot,price,sl_price,tp_price,comment)){
         Print("⚡ orioto.ai Scalp M1: ",comment);
         Logger::LogTrade("AI_Scalp",type,lot,price,comment);
      }
   }
   
   static void CloseAllAIPositions(string reason){
      int closed=0;
      for(int i=PositionsTotal()-1;i>=0;i--){
         if(!position.SelectByIndex(i)||position.Magic()!=ADVANCED_MagicNumber)continue;
         if(trade.PositionClose(position.Ticket()))closed++;
      }
      if(closed>0)Print("🤖 orioto.ai: إغلاق ",closed," صفقات - ",reason);
   }
   
   static void CloseLosingPositions(){
      int closed=0;
      for(int i=PositionsTotal()-1;i>=0;i--){
         if(!position.SelectByIndex(i)||position.Magic()!=ADVANCED_MagicNumber)continue;
         double pl=position.Profit()+position.Swap()+position.Commission();
         if(pl<0&&trade.PositionClose(position.Ticket()))closed++;
      }
      if(closed>0)Print("🤖 orioto.ai: إغلاق ",closed," صفقات خاسرة");
   }
   
   static void CloseWinningPositions(){
      int closed=0;
      for(int i=PositionsTotal()-1;i>=0;i--){
         if(!position.SelectByIndex(i)||position.Magic()!=ADVANCED_MagicNumber)continue;
         double pl=position.Profit()+position.Swap()+position.Commission();
         if(pl>0&&trade.PositionClose(position.Ticket()))closed++;
      }
      if(closed>0)Print("🤖 orioto.ai: جني أرباح ",closed," صفقات");
   }
   
   static double ExtractLotFromResponse(string response){
      int pos=StringFind(response,"LOT=");if(pos>=0)return NormalizeLot(StringToDouble(StringSubstr(response,pos+4,5)));
      pos=StringFind(response,"LOT_SIZE:");if(pos>=0)return NormalizeLot(StringToDouble(StringSubstr(response,pos+9,5)));
      return 0;
   }
   
   static double GetMarketConditionMultiplier(){
      string condition=GetMarketCondition();
      if(condition=="EXCELLENT")return 2.0;if(condition=="GOOD")return 1.5;
      if(condition=="VOLATILE")return 0.8;if(condition=="DANGEROUS")return 0.5;
      return 1.0;
   }
   
   static string GetMarketCondition(){
      string volatility=GetVolatilityLevel();double adx=GetCurrentADX(),spread=(Ask-Bid)/_Point;
      if(volatility=="LOW"&&adx>30&&spread<50)return "EXCELLENT";
      if(volatility=="NORMAL"&&adx>25)return "GOOD";
      if(volatility=="HIGH")return "VOLATILE";if(volatility=="EXTREME")return "DANGEROUS";
      return "NORMAL";
   }
   
   static void OverrideProtection(string overrideReason){
      if(!AI_FullControl)return;
      Print("🤖 orioto.ai: تجاوز الحماية - ",overrideReason);
      Protection::active=false;protectionActive=false;
      dynamicSettings.protectionOverridden=true;dynamicSettings.overrideTime=TimeCurrent();dynamicSettings.overrideReason=overrideReason;
      EventChartCustom(0,EVENT_PROTECTION_OVERRIDE,1,0,overrideReason);
   }
   
   static void DeepMarketAnalysis(){
      if(AI_Mode==AI_OFF)return;
      if(!TryLockAnalysis())return;
      deepAnalysisInProgress=true;
      string prompt=BuildEnhancedDeepPrompt();
      bool useSonnet=(AI_Mode!=AI_HAIKU);
      int nextAnalysis=GetDeepAnalysisInterval();
      Print("🤖 orioto.ai Deep Analysis (",(useSonnet?"Sonnet":"Haiku"),") - Next in ",nextAnalysis/60," min");
      string response=CallOriotoAPIWithRetry(prompt,false,!useSonnet);
      if(response!=""){
         ParseDeepAnalysis(response);
         ExecuteAIFullControl(response);
         ApplyAIRecommendations();
         CheckAndResetSettings();
      }
      if(emergencyStatus.required||g_PortfolioHealth.score<30||ConsecutiveLosses>=5){
         sessionTiming.emergencySonnetOnly=true;
         Print("🚨 تفعيل وضع Sonnet الطارئ");
      }
      else if(sessionTiming.emergencySonnetOnly&&g_PortfolioHealth.score>70){
         sessionTiming.emergencySonnetOnly=false;
         Print("✅ إلغاء وضع الطوارئ");
      }
      lastDeepAnalysis=TimeCurrent();
      deepAnalysisInProgress=false;
      UnlockAnalysis();
   }
   
   static int GetDeepAnalysisInterval(){
      if(sessionTiming.emergencySonnetOnly)return 60;
      if(g_CurrentSession=="ASIAN")return sessionTiming.asianSonnetMinutes*60;
      if(g_CurrentSession=="EUROPEAN"||g_CurrentSession=="EUROPEAN+AMERICAN")return sessionTiming.europeanSonnetMinutes*60;
      if(g_CurrentSession=="AMERICAN")return sessionTiming.americanSonnetMinutes*60;
      return AI_DeepAnalysisMinutes*60;
   }
   
   static string BuildEnhancedDeepPrompt(){
      string prompt="[DEEP_M1M5] "+_Symbol+"\nMKT: "+DoubleToString(Bid,_Digits)+"/"+DoubleToString(Ask,_Digits)+" S:"+IntegerToString((int)((Ask-Bid)/_Point))+" ADX:"+DoubleToString(GetCurrentADX(),0)+" RSI:"+DoubleToString(GetRSI(),0)+"\n";
      prompt+="M1: Trend="+GetM1Analysis()+" Mom="+DoubleToString(GetMomentum(1),1)+"\nM5: Trend="+GetM5Analysis()+" Mom="+DoubleToString(GetMomentum(5),1)+"\n";
      prompt+="PF: P:"+IntegerToString(PositionsTotal())+" PL:$"+DoubleToString(GetCurrentPL(),0)+" H:"+DoubleToString(g_PortfolioHealth.score,0)+"% CL:"+IntegerToString(ConsecutiveLosses)+"\n";
      if(NEWS_Enable&&newsCount>0){int nextNews=GetMinutesToNextHighImpactNews();if(nextNews>0&&nextNews<60)prompt+="NEWS: HIGH in "+IntegerToString(nextNews)+"m\n";}
      prompt+="SYS:";if(g_TurboSignal.active)prompt+="T";if(g_BoostSignal.active)prompt+="B";if(g_ScalpingSignal.active)prompt+="S";if(g_ForceRecovery.emergencyMode)prompt+="F!";prompt+="\n";
      prompt+="SET: MT:"+IntegerToString(dynamicSettings.currentMaxTrades)+" TGT:$"+DoubleToString(dynamicSettings.currentPortfolioTarget,0)+"\n";
      if(AI_UseExternalAPIs&&g_ExternalData.dataValid)prompt+="EXT: "+g_ExternalData.trend+" "+g_ExternalData.sentiment+"\n";
      prompt+="CMD? PRECISE_M1M5";
      return prompt;
   }
   
   static void ExecuteAIFullControl(string response){
      string upperResponse;
      upperResponse=response;
      StringToUpper(upperResponse);
      if(StringFind(upperResponse,"IMMEDIATE_TRADES:")>=0||StringFind(upperResponse,"BUY")>=0||StringFind(upperResponse,"SELL")>=0)ExecuteAIDirectTrades(response);
      if(StringFind(upperResponse,"CLOSE_POSITIONS:")>=0||StringFind(upperResponse,"CLOSE")>=0){
         if(StringFind(upperResponse,"CLOSE_ALL")>=0)CloseAllAIPositions("orioto.ai: تحليل عميق");
         else if(StringFind(upperResponse,"CLOSE_LOSING")>=0)CloseLosingPositions();
         else if(StringFind(upperResponse,"CLOSE_WINNING")>=0)CloseWinningPositions();
      }
      if(StringFind(upperResponse,"ACTIVATE_TURBO")>=0||StringFind(upperResponse,"ACT_T")>=0){g_TurboSignal.active=true;g_TurboSignal.confidence=95;Print("🤖 orioto.ai: تفعيل TURBO");}
      if(StringFind(upperResponse,"ACTIVATE_BOOST")>=0||StringFind(upperResponse,"ACT_B")>=0){g_BoostSignal.active=true;g_BoostSignal.confidence=95;Print("🤖 orioto.ai: تفعيل BOOST");}
      if(StringFind(upperResponse,"ACTIVATE_SCALPING")>=0||StringFind(upperResponse,"ACT_S")>=0){g_ScalpingSignal.active=true;g_ScalpingSignal.confidence=95;Print("🤖 orioto.ai: تفعيل SCALPING");}
      if(StringFind(upperResponse,"DEACTIVATE_ALL")>=0||StringFind(upperResponse,"DEACT_ALL")>=0)DeactivateAllSystems();
      int posLot=StringFind(upperResponse,"LOT_MULT:");if(posLot<0)posLot=StringFind(upperResponse,"LM:");
      if(posLot>=0)currentAnalysis.suggestedLotMultiplier=StringToDouble(StringSubstr(response,posLot+3,3));
      if(StringFind(upperResponse,"SETTINGS_OVERRIDE:")>=0||StringFind(upperResponse,"SO:")>=0)OverrideSystemSettings(response);
      if(StringFind(upperResponse,"ULTRA_BALANCE:YES")>=0||StringFind(upperResponse,"UB:Y")>=0){UltraBalance::ForceIntervention();Print("🤖 orioto.ai: تفعيل Ultra Balance");}
      if(StringFind(upperResponse,"SCALPING_MODE:YES")>=0||StringFind(upperResponse,"SM:Y")>=0)EnableScalpingMode();
   }
   
   static void DeactivateAllSystems(){g_TurboSignal.active=false;g_BoostSignal.active=false;g_ScalpingSignal.active=false;g_ForceRecovery.emergencyMode=false;Print("🤖 orioto.ai: إيقاف جميع الأنظمة");}
   
   static void OverrideSystemSettings(string response){
      int pos=StringFind(response,"MAX_TRADES:");if(pos<0)pos=StringFind(response,"MT:");
      if(pos>=0){dynamicSettings.currentMaxTrades=(int)StringToInteger(StringSubstr(response,pos+3,3));Print("🤖 orioto.ai: Max Trades → ",dynamicSettings.currentMaxTrades);}
      pos=StringFind(response,"PORTFOLIO_TARGET:");if(pos<0)pos=StringFind(response,"PT:");
      if(pos>=0){
         double newTarget=StringToDouble(StringSubstr(response,pos+3,10));
         if(currentAnalysis.marketState>=2&&currentAnalysis.confidence>85){if(newTarget>dynamicSettings.originalPortfolioTarget*5)newTarget=dynamicSettings.originalPortfolioTarget*5;}
         else{if(newTarget>dynamicSettings.originalPortfolioTarget*2)newTarget=dynamicSettings.originalPortfolioTarget*2;}
         dynamicSettings.currentPortfolioTarget=newTarget;Print("🤖 orioto.ai: Portfolio Target → $",DoubleToString(newTarget,2));
      }
   }
   
   static void EnableScalpingMode(){
      Print("🤖 orioto.ai: تفعيل وضع السكالبينج المكثف على M1");
      for(int i=0;i<10&&PositionsTotal()<AI_MaxPositions;i++){
         int direction=GetSmartDirectionM1M5();
         if(direction!=0){
            ENUM_ORDER_TYPE type=direction>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
            ExecuteScalpTrade(type,"AI_SCALP_M1_BATCH_"+IntegerToString(i+1));
            Sleep(200);
         }
      }
   }
   
   static bool CheckAPILimits(){
      if(TimeCurrent()-dailyReset>86400){dailyCalls=0;dailyReset=TimeCurrent();haikuCallCount=0;sonnetCallCount=0;}
      if(dailyCalls>=AI_MaxDailyCalls){Print("⚠️ تم الوصول للحد اليومي لمكالمات API: ",dailyCalls,"/",AI_MaxDailyCalls);return false;}
      static datetime lastAPICall=0;
      if(TimeCurrent()-lastAPICall<5)return false;
      static int callsThisMinute=0;static datetime minuteStart=0;
      if(TimeCurrent()-minuteStart>60){callsThisMinute=0;minuteStart=TimeCurrent();}
      int maxPerMinute=AI_Mode==AI_SONNET?50:100;
      if(callsThisMinute>=maxPerMinute){Print("⚠️ تجاوز حد المكالمات بالدقيقة");return false;}
      callsThisMinute++;
      lastAPICall=TimeCurrent();
      return true;
   }
   
   static string CallOriotoAPI(string prompt,bool fast,bool useHaiku=false){
      if(apiKey=="")apiKey=GetAPIKey();
      if(apiKey==""||!CheckAPILimits())return LocalAnalysis(prompt,fast);
      string model=useHaiku?"claude-3-5-haiku-20241022":"claude-3-5-sonnet-20241022",url="https://api.anthropic.com/v1/messages";
      string json="{\"model\":\""+model+"\",\"max_tokens\":1000,\"messages\":[{\"role\":\"user\",\"content\":\""+EscapeJSON(prompt)+"\"}],\"temperature\":0.7}";
      uchar jsonData[];StringToCharArray(json,jsonData,0,StringLen(json));
      string headers="Content-Type: application/json\r\nx-api-key: "+apiKey+"\r\nanthropic-version: 2023-06-01";
      char result[];string resultHeaders;
      Print("🤖 orioto.ai ",fast?"Fast":"Deep"," Analysis (",model,") ... (",dailyCalls+1,"/",AI_MaxDailyCalls,")");
      Print("📊 Haiku calls: ",haikuCallCount," | Sonnet calls: ",sonnetCallCount);
      int res=WebRequest("POST",url,headers,10000,jsonData,result,resultHeaders);
      dailyCalls++;
      if(res==-1){int error=GetLastError();Print("❌ خطأ WebRequest: ",error);Logger::LogError("CallOriotoAPI","WebRequest error "+IntegerToString(error));return LocalAnalysis(prompt,fast);}
      if(res==200){
         string response=CharArrayToString(result,0,WHOLE_ARRAY,CP_UTF8);
         int contentStart=StringFind(response,"\"text\":\"");
         if(contentStart>=0){
            contentStart+=8;int contentEnd=StringFind(response,"\"",contentStart);
            if(contentEnd>contentStart){
               string content=StringSubstr(response,contentStart,contentEnd-contentStart);
               StringReplace(content,"\\n","\n");StringReplace(content,"\\\"","\"");
               if(useHaiku)lastSuccessfulHaikuCall=TimeCurrent();else lastSuccessfulSonnetCall=TimeCurrent();
               return content;
            }
         }
      }else if(res==429){Print("⚠️ Rate limit - تجاوز حد المكالمات");return LocalAnalysis(prompt,fast);}
      return LocalAnalysis(prompt,fast);
   }
   
   static string EscapeJSON(string text){StringReplace(text,"\\","\\\\");StringReplace(text,"\"","\\\"");StringReplace(text,"\n","\\n");StringReplace(text,"\r","\\r");StringReplace(text,"\t","\\t");return text;}
   
   static string LocalAnalysis(string prompt,bool fast){
      if(StringFind(prompt,"[FAST")>=0)return AnalyzeEnhancedFastPrompt(prompt);
      if(StringFind(prompt,"[DEEP")>=0)return AnalyzeEnhancedDeepPrompt(prompt);
      if(StringFind(prompt,"immediate action")>=0||StringFind(prompt,"QUICK")>=0){
         if(ConsecutiveLosses>=5)return "YES - 5 consecutive losses detected. Close all positions.";
         if(g_PortfolioHealth.score<30)return "YES - Portfolio health critical. Reduce exposure.";
         double pl=GetCurrentPL();if(pl<-RISK_MaxDailyLoss)return "YES - Daily loss limit reached. Stop trading.";
         if(GetVolatilityLevel()=="EXTREME")return "YES - Extreme volatility. Pause trading.";
         int direction=GetSmartDirectionM1M5();
         if(direction==1)return "BUY - Market analysis positive";if(direction==-1)return "SELL - Market analysis negative";
         if(protectionActive&&AI_FullControl){
            string currentVolatility=GetVolatilityLevel();
            if(GetCurrentADX()>50&&g_CurrentSession=="EUROPEAN+AMERICAN"&&currentVolatility=="NORMAL")return "OVERRIDE_PROTECTION - Excellent market conditions";
         }
         return "WAIT - Market conditions acceptable.";
      }
      string response="MARKET_STATE: ";
      double adx=GetCurrentADX(),rsi=GetRSI();string currentVolatility=GetVolatilityLevel();
      int realTrend=GetRealMarketTrendM1M5();
      if(adx>40)response+=realTrend>0?"2":"-2";else if(adx>25)response+=realTrend>0?"1":"-1";else response+="0";
      response+="\nACTION: ";
      if(newsCount>0&&IsHighImpactNewsSoon())response+="WAIT";
      else if(g_PortfolioHealth.score<50)response+="WAIT";
      else if(currentVolatility=="EXTREME")response+="CLOSE_ALL";
      else if(realTrend>0&&adx>30&&rsi<70)response+="BUY";
      else if(realTrend<0&&adx>30&&rsi>30)response+="SELL";
      else response+="WAIT";
      response+="\nCONFIDENCE: "+DoubleToString(MathMin(95,adx*2),0);
      response+="\nLOT_MULTIPLIER: ";
      if(currentVolatility=="LOW"&&sessionWins>sessionLosses*2)response+="1.5";
      else if(currentVolatility=="HIGH"||ConsecutiveLosses>=3)response+="0.5";
      else if(currentVolatility=="EXTREME")response+="0.3";
      else response+="1.0";
      response+="\nRISK_ASSESSMENT: ";
      if(IsHighImpactNewsSoon()||g_PortfolioHealth.score<60||currentVolatility=="EXTREME")response+="HIGH";
      else if(currentVolatility=="HIGH"||ConsecutiveLosses>=2)response+="MEDIUM";
      else response+="LOW";
      if(currentVolatility=="LOW"&&adx>35&&sessionWins>5){
         response+="\nMAX_TRADES: "+IntegerToString((int)(dynamicSettings.originalMaxTrades*1.5));
         response+="\nPORTFOLIO_TARGET: "+DoubleToString(dynamicSettings.originalPortfolioTarget*2,2);
      }
      if(protectionActive&&AI_FullControl&&currentAnalysis.marketState>=2&&currentAnalysis.confidence>90)response+="\nOVERRIDE_PROTECTION: YES - Excellent market conditions";
      return response;
   }
   
   static string AnalyzeEnhancedFastPrompt(string prompt){
      if(StringFind(prompt,"M1:SU")>=0&&StringFind(prompt,"M5:SU")>=0)return "SCALP_MULTIPLE BUY_M1 LOT=0.05";
      if(StringFind(prompt,"M1:SD")>=0&&StringFind(prompt,"M5:SD")>=0)return "SCALP_MULTIPLE SELL_M1 LOT=0.05";
      if(StringFind(prompt,"M1:SU")>=0&&StringFind(prompt,"M5:N")>=0)return "BUY LOT=0.1 TP=100 SL=50";
      if(StringFind(prompt,"M1:SD")>=0&&StringFind(prompt,"M5:N")>=0)return "SELL LOT=0.1 TP=100 SL=50";
      if(StringFind(prompt,"M5:SU")>=0&&StringFind(prompt,"VOL:N")>=0)return "M5_TREND_BUY LOT=0.15";
      if(StringFind(prompt,"M5:SD")>=0&&StringFind(prompt,"VOL:N")>=0)return "M5_TREND_SELL LOT=0.15";
      if(StringFind(prompt,"L3")>=0||StringFind(prompt,"L4")>=0||StringFind(prompt,"L5")>=0)return "CLOSE_LOSING UB:Y";
      if(StringFind(prompt,"H:")>=0){int hPos=StringFind(prompt,"H:")+2;double health=StringToDouble(StringSubstr(prompt,hPos,3));if(health<30)return "CLOSE_ALL";}
      if(StringFind(prompt,"VOL:X")>=0)return "WAIT";
      return "WAIT";
   }
   
   static string AnalyzeEnhancedDeepPrompt(string prompt){
      string response="";
      if(StringFind(prompt,"M1: Trend=SU")>=0&&StringFind(prompt,"M5: Trend=SU")>=0){response+="IMMEDIATE_TRADES: BUY LOT_MULT: 1.5 ACT_T ";}
      if(StringFind(prompt,"M1: Trend=SD")>=0&&StringFind(prompt,"M5: Trend=SD")>=0){response+="IMMEDIATE_TRADES: SELL LOT_MULT: 1.5 ACT_T ";}
      if(StringFind(prompt,"CL:3")>=0||StringFind(prompt,"CL:4")>=0||StringFind(prompt,"CL:5")>=0){response+="CLOSE_LOSING UB:Y SM:Y ";}
      if(StringFind(prompt,"H:")>=0){int hPos=StringFind(prompt,"H:")+2;double health=StringToDouble(StringSubstr(prompt,hPos,3));if(health<50){response+="LM:0.5 MT:25 ";}}
      if(StringFind(prompt,"NEWS: HIGH")>=0)response+="CLOSE_ALL ";
      if(StringFind(prompt,"ADX:")>=0){int adxPos=StringFind(prompt,"ADX:")+4;double adx=StringToDouble(StringSubstr(prompt,adxPos,3));if(adx>40){response+="ACT_T LM:1.5 ";}}
      if(StringFind(prompt,"EXT: UP POS")>=0)response+="BUY ";else if(StringFind(prompt,"EXT: DOWN NEG")>=0)response+="SELL ";
      if(response=="")response="WAIT";
      return response;
   }
   
   static int GetRealMarketTrendM1M5(){
      int m1Trend=GetM1DetailedTrend(),m5Trend=GetM5DetailedTrend();
      if(m1Trend==m5Trend&&m1Trend!=0)return m1Trend;
      if(m5Trend!=0&&GetCurrentADX()>25)return m5Trend;
      return GetCombinedTrend();
   }
   
   static int GetM1DetailedTrend(){
      double ma_fast[],ma_slow[],macd_main[],macd_signal[],rsi[];
      ArraySetAsSeries(ma_fast,true);
      ArraySetAsSeries(ma_slow,true);
      ArraySetAsSeries(macd_main,true);
      ArraySetAsSeries(macd_signal,true);
      ArraySetAsSeries(rsi,true);
      
      int ma_fast_copied=CopyBuffer(h_MA_Fast,0,0,10,ma_fast);
      int ma_slow_copied=CopyBuffer(h_MA_Slow,0,0,10,ma_slow);
      int macd_main_copied=CopyBuffer(h_MACD,0,0,5,macd_main);
      int macd_signal_copied=CopyBuffer(h_MACD,1,0,5,macd_signal);
      int rsi_copied=CopyBuffer(h_RSI,0,0,5,rsi);
      
      if(ma_fast_copied<10||ma_slow_copied<10||macd_main_copied<5||macd_signal_copied<5||rsi_copied<5){
         if(ADVANCED_EnableLogging)Logger::LogError("GetM1DetailedTrend","Insufficient indicator data");
         return 0;
      }
      
      int signals=0;
      
      if(ma_fast[0]>ma_slow[0]&&ma_fast[1]>ma_slow[1])signals++;
      else if(ma_fast[0]<ma_slow[0]&&ma_fast[1]<ma_slow[1])signals--;
      
      double ma_slope=(ma_fast[0]-ma_fast[4])/g_Point;
      if(ma_slope>10)signals++;
      else if(ma_slope<-10)signals--;
      
      if(macd_main[0]>macd_signal[0]&&macd_main[0]>0)signals++;
      else if(macd_main[0]<macd_signal[0]&&macd_main[0]<0)signals--;
      
      if(rsi[0]>55&&rsi[0]>rsi[2])signals++;
      else if(rsi[0]<45&&rsi[0]<rsi[2])signals--;
      
      if(signals>=3)return 1;
      if(signals<=-3)return -1;
      return 0;
   }
   
   static int GetM5DetailedTrend(){
      double ma_fast[],ma_slow[],adx_plus[],adx_minus[];
      ArraySetAsSeries(ma_fast,true);ArraySetAsSeries(ma_slow,true);ArraySetAsSeries(adx_plus,true);ArraySetAsSeries(adx_minus,true);
      if(CopyBuffer(h_MA_Fast_M5,0,0,10,ma_fast)<10||CopyBuffer(h_MA_Slow_M5,0,0,10,ma_slow)<10||CopyBuffer(h_ADX_M5,1,0,3,adx_plus)<3||CopyBuffer(h_ADX_M5,2,0,3,adx_minus)<3)return 0;
      int signals=0;
      if(ma_fast[0]>ma_slow[0]&&ma_fast[1]>ma_slow[1]&&ma_fast[2]>ma_slow[2])signals+=2;
      else if(ma_fast[0]<ma_slow[0]&&ma_fast[1]<ma_slow[1]&&ma_fast[2]<ma_slow[2])signals-=2;
      if(adx_plus[0]>adx_minus[0]+5)signals+=2;else if(adx_minus[0]>adx_plus[0]+5)signals-=2;
      double close[];if(CopyClose(_Symbol,PERIOD_M5,0,20,close)==20){
         ArraySetAsSeries(close,true);double avg5=0,avg20=0;
         for(int i=0;i<5;i++)avg5+=close[i];for(int i=0;i<20;i++)avg20+=close[i];
         avg5/=5;avg20/=20;
         if(close[0]>avg5&&avg5>avg20)signals++;else if(close[0]<avg5&&avg5<avg20)signals--;
      }
      if(signals>=3)return 1;if(signals<=-3)return -1;return 0;
   }
   
   static int GetCombinedTrend(){
      int totalSignals=0,m1=GetM1DetailedTrend();if(m1!=0)totalSignals+=m1*2;
      int m5=GetM5DetailedTrend();if(m5!=0)totalSignals+=m5*3;
      double adx=GetCurrentADX();if(adx>30&&mainTrend!=0)totalSignals+=mainTrend*2;
      if(AI_UseExternalAPIs&&g_ExternalData.dataValid){
         if(g_ExternalData.trend=="UP")totalSignals+=2;else if(g_ExternalData.trend=="DOWN")totalSignals-=2;
      }
      if(totalSignals>=5)return 1;if(totalSignals<=-5)return -1;return 0;
   }
   
   static int GetSmartDirectionM1M5(){
      int totalDirection=0,signals=0;double totalConfidence=0;
      int realTrend=GetRealMarketTrendM1M5();
      if(realTrend!=0){totalDirection+=realTrend*5;totalConfidence+=90;signals+=5;}
      if(g_TurboSignal.active&&g_TurboSignal.confidence>70){
         if(realTrend==0||g_TurboSignal.direction==realTrend){totalDirection+=g_TurboSignal.direction*3;totalConfidence+=g_TurboSignal.confidence;signals+=3;}
      }
      if(g_BoostSignal.active&&g_BoostSignal.confidence>70){
         if(realTrend==0||g_BoostSignal.direction==realTrend){totalDirection+=g_BoostSignal.direction*3;totalConfidence+=g_BoostSignal.confidence;signals+=3;}
      }
      if(g_ScalpingSignal.active&&g_ScalpingSignal.confidence>60){
         if(realTrend==0||g_ScalpingSignal.direction==realTrend){totalDirection+=g_ScalpingSignal.direction*2;totalConfidence+=g_ScalpingSignal.confidence;signals+=2;}
      }
      if(g_LastUSTPPrediction.direction!=0&&TimeCurrent()<g_LastUSTPPrediction.validUntil){
         if(realTrend==0||g_LastUSTPPrediction.direction==realTrend){totalDirection+=g_LastUSTPPrediction.direction*3;totalConfidence+=g_LastUSTPPrediction.confidence;signals+=3;}
      }
      if(AI_UseExternalAPIs&&g_ExternalData.dataValid){
         if(g_ExternalData.trend=="UP"&&(realTrend==0||realTrend==1)){totalDirection+=2;totalConfidence+=70;signals+=2;}
         else if(g_ExternalData.trend=="DOWN"&&(realTrend==0||realTrend==-1)){totalDirection-=2;totalConfidence+=70;signals+=2;}
      }
      if(signals==0)return 0;
      double avgConfidence=totalConfidence/signals,minConfidence=AI_Mode!=AI_OFF?AI_MinActionConfidence:60.0;
      if(avgConfidence<minConfidence)return 0;
      if(MathAbs(totalDirection)>=signals*0.7)return totalDirection>0?1:-1;
      return 0;
   }
   
   static void HandleEmergency(){
      if(!emergencyStatus.required)return;
      Print("🚨 تدخل طارئ: ",emergencyStatus.reason);
      sessionTiming.emergencySonnetOnly=true;
      if(emergencyStatus.urgency>80){
         for(int i=PositionsTotal()-1;i>=0;i--){
            if(!position.SelectByIndex(i)||position.Magic()!=ADVANCED_MagicNumber)continue;
            double pl=position.Profit()+position.Swap()+position.Commission();
            if(pl<-10&&trade.PositionClose(position.Ticket()))Print("⛔ إغلاق طارئ: ",position.Symbol()," خسارة: $",DoubleToString(-pl,2));
         }
      }
      if(emergencyStatus.urgency>90&&!AI_FullControl)Protection::Activate("تدخل AI طارئ",120);
      string emergencyPrompt="[EMERGENCY_M1M5] "+emergencyStatus.reason+"\nUrgency: "+DoubleToString(emergencyStatus.urgency,0)+"%\nPortfolio Health: "+DoubleToString(g_PortfolioHealth.score,0)+"%\nOpen Positions: "+IntegerToString(PositionsTotal())+"\nTotal Loss: $"+DoubleToString(g_LastLossAmount,2)+"\n\nIMMEDIATE ACTION REQUIRED!";
      string response=CallOriotoAPIWithRetry(emergencyPrompt,false,false);
      ExecuteAIDirectTrades(response);
      emergencyStatus.required=false;
   }
   
   static void ParseDeepAnalysis(string response){
      previousAnalysis=currentAnalysis;currentAnalysis.time=TimeCurrent();
      if(StringFind(response,"MS:")>=0){int pos=StringFind(response,"MS:")+3;currentAnalysis.marketState=(int)StringToInteger(StringSubstr(response,pos,2));}
      else{int pos=StringFind(response,"MARKET_STATE:");if(pos>=0){string state=StringSubstr(response,pos+13,2);currentAnalysis.marketState=(int)StringToInteger(state);}}
      if(StringFind(response,"BUY")>=0)currentAnalysis.suggestedAction=1;
      else if(StringFind(response,"SELL")>=0)currentAnalysis.suggestedAction=-1;
      else if(StringFind(response,"CLOSE_ALL")>=0)currentAnalysis.suggestedAction=2;
      else currentAnalysis.suggestedAction=0;
      int pos=StringFind(response,"CONF:");if(pos<0)pos=StringFind(response,"CONFIDENCE:");
      if(pos>=0)currentAnalysis.confidence=StringToDouble(StringSubstr(response,pos+5,3));
      pos=StringFind(response,"LM:");if(pos<0)pos=StringFind(response,"LOT_MULTIPLIER:");
      if(pos>=0)currentAnalysis.suggestedLotMultiplier=StringToDouble(StringSubstr(response,pos+3,3));
      pos=StringFind(response,"RISK:");
      if(pos>=0){
         string risk=StringSubstr(response,pos+5,6);
         if(StringFind(risk,"HIGH")>=0)currentAnalysis.riskScore=80;
         else if(StringFind(risk,"MEDIUM")>=0)currentAnalysis.riskScore=50;
         else currentAnalysis.riskScore=20;
      }
      if(AI_FullControl&&(StringFind(response,"OVERRIDE_PROTECTION")>=0||StringFind(response,"OP:Y")>=0))OverrideProtection("orioto.ai: Excellent market conditions");
   }
   
   static void ApplyAIRecommendations(){if(currentAnalysis.suggestedAction==2){SmartPortfolio::SafeCloseAllPositions("توصية AI");return;}}
   
   static void FetchAndAnalyzeNews(){
      if(!NEWS_Enable||AI_Mode==AI_OFF)return;
      static datetime lastNewsFetch=0;if(TimeCurrent()-lastNewsFetch<300)return;
      string newsUrl="https://nfs.faireconomy.media/ff_calendar_thisweek.json";
      char post[],result[];ArrayResize(post,0);
      string headers="User-Agent: Mozilla/5.0\r\nAccept: application/json",resultHeaders;
      int res=WebRequest("GET",newsUrl,headers,5000,post,result,resultHeaders);
      if(res==200){string newsData=CharArrayToString(result,0,WHOLE_ARRAY,CP_UTF8);ParseNewsData(newsData);}
      else SimulateUpcomingNews();
      lastNewsFetch=TimeCurrent();
      if(IsHighImpactNewsSoon()){
         Print("⚠️ أخبار عالية التأثير قادمة - تعديل الإعدادات");
         if(dynamicSettings.currentMaxTrades>dynamicSettings.originalMaxTrades)dynamicSettings.currentMaxTrades=dynamicSettings.originalMaxTrades;
         int minutesUntil=GetMinutesToNextHighImpactNews();
         if(minutesUntil>0&&minutesUntil<=NEWS_MinutesBeforeEvent){Print("🔔 تنبيه: أخبار مهمة بعد ",minutesUntil," دقيقة");EventChartCustom(0,EVENT_NEWS_ALERT,minutesUntil,0,"HIGH_IMPACT_ALERT");}
      }
   }
   
   static void ParseNewsData(string jsonData){
      newsCount=0;datetime now=TimeCurrent();int pos=0;
      while(pos>=0&&newsCount<10){
         pos=StringFind(jsonData,"\"date\":",pos);if(pos<0)break;
         int dateStart=StringFind(jsonData,"\"",pos+7)+1,dateEnd=StringFind(jsonData,"\"",dateStart);
         if(dateStart>0&&dateEnd>dateStart){
            string dateStr=StringSubstr(jsonData,dateStart,dateEnd-dateStart);
            int currPos=StringFind(jsonData,"\"country\":",pos);
            if(currPos>0&&currPos<pos+500){
               int currStart=StringFind(jsonData,"\"",currPos+10)+1,currEnd=StringFind(jsonData,"\"",currStart);
               string currency=StringSubstr(jsonData,currStart,currEnd-currStart);
               int impactPos=StringFind(jsonData,"\"impact\":",pos);
               if(impactPos>0&&impactPos<pos+500){
                  int impactStart=StringFind(jsonData,"\"",impactPos+9)+1,impactEnd=StringFind(jsonData,"\"",impactStart);
                  string impact=StringSubstr(jsonData,impactStart,impactEnd-impactStart);
                  if(impact=="High"||(!NEWS_HighImpactOnly&&impact=="Medium")){
                     upcomingNews[newsCount].currency=currency;
                     upcomingNews[newsCount].impact=impact=="High"?NEWS_HIGH:NEWS_MEDIUM;
                     upcomingNews[newsCount].processed=false;
                     newsCount++;
                  }
               }
            }
         }
         pos=dateEnd;
      }
   }
   
   static void SimulateUpcomingNews(){
      newsCount=0;datetime now=TimeCurrent();MqlDateTime dt;TimeToStruct(now,dt);
      int newsHours[6]={8,10,13,14,16,20};
      for(int i=0;i<6;i++){
         if(dt.hour<newsHours[i]){
            datetime newsTime=StringToTime(TimeToString(now,TIME_DATE)+" "+IntegerToString(newsHours[i])+":30");
            if(newsTime>now){
               upcomingNews[newsCount].time=newsTime;upcomingNews[newsCount].currency=StringSubstr(_Symbol,0,3);
               upcomingNews[newsCount].title="Economic Data Release";upcomingNews[newsCount].impact=NEWS_HIGH;
               upcomingNews[newsCount].processed=false;newsCount++;
               if(newsCount>=5)break;
            }
         }
      }
   }
   
   static int GetMinutesToNextHighImpactNews(){
      datetime now=TimeCurrent();int minMinutes=999999;
      for(int i=0;i<newsCount;i++){
         if(upcomingNews[i].impact==NEWS_HIGH&&upcomingNews[i].time>now){
            int minutes=(int)((upcomingNews[i].time-now)/60);
            if(minutes<minMinutes)minMinutes=minutes;
         }
      }
      return minMinutes<999999?minMinutes:-1;
   }
   
   static void CheckAndResetSettings(){
      if(currentAnalysis.marketState<=-1||currentAnalysis.riskScore>70){
         if(dynamicSettings.currentMaxTrades>dynamicSettings.originalMaxTrades||dynamicSettings.currentPortfolioTarget>dynamicSettings.originalPortfolioTarget){
            Print("⚠️ AI: إعادة الإعدادات للأصل - السوق متدهور");
            dynamicSettings.currentMaxTrades=dynamicSettings.originalMaxTrades;
            dynamicSettings.currentPortfolioTarget=dynamicSettings.originalPortfolioTarget;
            dynamicSettings.lastModificationReason="Reset - Market Risk";
         }
         if(dynamicSettings.protectionOverridden){dynamicSettings.protectionOverridden=false;Print("⚠️ AI: إلغاء تجاوز الحماية - السوق متدهور");}
      }
   }
   
   static void UpdateCurrentSession(){
      if(TimeCurrent()-g_LastSessionCheck<300)return;
      g_CurrentSession=GetCurrentSession();g_LastSessionCheck=TimeCurrent();
      static string lastSession="";
      if(lastSession!=g_CurrentSession&&lastSession!=""){
         EventChartCustom(0,EVENT_SESSION_CHANGE,0,0,g_CurrentSession);
         Print("📍 تغيير الجلسة: ",lastSession," → ",g_CurrentSession);
         if(AI_Mode==AI_ADAPTIVE)Print("🤖 orioto.ai: تعديل الاستراتيجية للجلسة ",g_CurrentSession);
      }
      lastSession=g_CurrentSession;
   }
};

int AITradingSystem::analysisLock=0;
string AITradingSystem::apiKey=AI_APIKey;
int AITradingSystem::dailyCalls=0,AITradingSystem::haikuCallCount=0,AITradingSystem::sonnetCallCount=0,AITradingSystem::sessionWins=0,AITradingSystem::sessionLosses=0,AITradingSystem::newsCount=0;
datetime AITradingSystem::lastFastAnalysis=0,AITradingSystem::lastDeepAnalysis=0,AITradingSystem::dailyReset=0;
NewsEvent AITradingSystem::upcomingNews[10];
AIAnalysis AITradingSystem::currentAnalysis,AITradingSystem::previousAnalysis;
EmergencyAction AITradingSystem::emergencyStatus;
DynamicSettings AITradingSystem::dynamicSettings;
SessionTiming AITradingSystem::sessionTiming;
double AITradingSystem::sessionProfitLoss=0,AITradingSystem::maxDrawdownToday=0,AITradingSystem::bestStrategy=0;
bool AITradingSystem::fastAnalysisInProgress=false,AITradingSystem::deepAnalysisInProgress=false;
datetime AITradingSystem::lastSuccessfulHaikuCall=0,AITradingSystem::lastSuccessfulSonnetCall=0;

class USTPSystem{
public:
   struct TickData{double price;datetime time;long volume;};
   static TickData ticks[100];
   static int tickIndex;
   
   static void AddTick(double price,long volume){
      tickIndex=(tickIndex+1)%100;ticks[tickIndex].price=price;ticks[tickIndex].time=TimeCurrent();ticks[tickIndex].volume=volume;
   }
   
   static USTPPrediction GetPrediction(){
      USTPPrediction pred={0,0,0,"",0};
      if(!USTP_Enable||TimeCurrent()-lastUSTPSignal<USTP_MinSignalGap)return pred;
      int signals=0;double totalConfidence=0;
      if(USTP_UseTickAnalysis){
         double velocity=0,momentum=0;int validTicks=0;
         for(int i=0;i<100&&!IsStopped();i++){
            if(ticks[i].time==0||TimeCurrent()-ticks[i].time>10)continue;
            if(i>0&&ticks[i-1].time>0){
               double change=ticks[i].price-ticks[i-1].price,timeDiff=(double)(ticks[i].time-ticks[i-1].time);
               if(timeDiff>0){velocity+=change/timeDiff;validTicks++;}
            }
         }
         if(validTicks>5){
            momentum=velocity/validTicks*1000;
            if(MathAbs(momentum)>USTP_MinMomentum){
               pred.direction+=(momentum>0)?1:-1;totalConfidence+=MathMin(90,MathAbs(momentum)*2);signals++;
               pred.reason="Momentum="+DoubleToString(momentum,1);
            }
         }
      }
      if(USTP_UseMicroStructure){
         MqlTick recent[];int copied=CopyTicks(_Symbol,recent,COPY_TICKS_ALL,0,20);
         if(copied==20){
            int buyPressure=0,sellPressure=0;
            for(int i=1;i<20&&!IsStopped();i++){
               if(recent[i].volume>recent[i-1].volume){
                  if(recent[i].bid>recent[i-1].bid)buyPressure++;else sellPressure++;
               }
            }
            if(buyPressure>sellPressure+3){pred.direction+=1;totalConfidence+=70;signals++;if(pred.reason!="")pred.reason+=" + ";pred.reason+="BuyPressure";}
            else if(sellPressure>buyPressure+3){pred.direction-=1;totalConfidence+=70;signals++;if(pred.reason!="")pred.reason+=" + ";pred.reason+="SellPressure";}
         }
      }
      if(signals>=2&&MathAbs(pred.direction)>=2){
         pred.direction=(pred.direction>0)?1:-1;pred.confidence=totalConfidence/signals;
         if(pred.confidence>=USTP_MinConfidence){
            pred.expectedMove=50;pred.validUntil=TimeCurrent()+USTP_PredictionMinutes*60;
            lastUSTPSignal=TimeCurrent();dailyUSTPCount++;
            Print("🎯 تنبؤ فوري:",pred.direction>0?"صعود":"هبوط"," ثقة:",DoubleToString(pred.confidence,1),"%");
            EventChartCustom(0,EVENT_USTP_SIGNAL,pred.direction,pred.confidence,pred.reason);
            g_LastUSTPPrediction=pred;
         }
      }
      return pred;
   }
};

USTPSystem::TickData USTPSystem::ticks[100];
int USTPSystem::tickIndex=0;

class UltraBalance{
public:
   static bool operation_in_progress;
   static int balance_trades_count,exceptional_trades_count;
   static datetime last_exceptional_trade,last_force_intervention,operation_start_time;   
   static const int OPERATION_TIMEOUT;
   
   struct PortfolioData{int total_positions,smart_direction;double total_loss,required_profit,optimal_lot,ai_confidence,ai_suggested_lot;bool needs_intervention,data_valid;string intervention_reason;};
   
   static void Reset(){balance_trades_count=0;exceptional_trades_count=0;operation_in_progress=false;}
   
   static void Check(){
      if(!ULTRA_Enable)return;
      
      if(operation_in_progress){
         if(TimeCurrent()-operation_start_time>OPERATION_TIMEOUT){
            Print("⚠️ Ultra Balance timeout - إعادة تعيين");
            operation_in_progress=false;
         }else return;
      }
      
      static datetime last_check=0;datetime current=TimeCurrent();
      if(current-last_check<(double)ULTRA_CheckIntervalMS/1000.0)return;
      last_check=current;
      
      double ultra_normal_loss=0,ultra_exceptional_loss=0;
      for(int i=0;i<PositionsTotal();i++){
          if(!position.SelectByIndex(i))continue;
          string comment=position.Comment();
          double pnl=position.Profit()+position.Swap()+position.Commission();
          if(pnl<0){
              if(StringFind(comment,"ULTRA_EXCEPTIONAL")>=0)ultra_exceptional_loss+=MathAbs(pnl);
              else if(StringFind(comment,"ULTRA_BALANCE")>=0)ultra_normal_loss+=MathAbs(pnl);
          }
      }
      
      if(ultra_exceptional_loss>ULTRA_ExceptionalMaxLoss)CloseUltraPositions("EXCEPTIONAL","تجاوز حد الاستثنائية");
      if(ultra_normal_loss+ultra_exceptional_loss>ULTRA_MaxOpenLoss)CloseUltraPositions("ALL","تجاوز حد Ultra الكلي");
      
      PortfolioData data=AnalyzePortfolio();
      bool shouldActivateUltra=false;
      
      if(g_ForceRecovery.totalLossAmount>=ULTRA_MinLossToBalance){
         shouldActivateUltra=true;
         data.total_loss=MathMax(data.total_loss,g_ForceRecovery.totalLossAmount);
         data.needs_intervention=true;data.data_valid=true;
         data.intervention_reason="خسائر محققة: $"+DoubleToString(g_ForceRecovery.totalLossAmount,2);
         Print("⚖️ Ultra Balance: اكتشاف خسائر محققة $",DoubleToString(g_ForceRecovery.totalLossAmount,2));
      }
      
      if(ConsecutiveLosses>=2){
         shouldActivateUltra=true;data.needs_intervention=true;data.data_valid=true;
         data.intervention_reason="خسائر متتالية: "+IntegerToString(ConsecutiveLosses);
         Print("⚖️ Ultra Balance: ",ConsecutiveLosses," خسائر متتالية - تدخل فوري");
      }
      
      if(g_PortfolioHealth.score<70&&data.total_loss>=ULTRA_MinLossToBalance/2){
         shouldActivateUltra=true;data.needs_intervention=true;data.data_valid=true;
         data.intervention_reason="صحة المحفظة: "+DoubleToString(g_PortfolioHealth.score,1)+"%";
         Print("⚖️ Ultra Balance: صحة المحفظة منخفضة - تدخل وقائي");
      }
      
      if(data.total_loss>=ULTRA_MinLossToBalance){
         shouldActivateUltra=true;data.needs_intervention=true;data.data_valid=true;
         if(data.intervention_reason=="")data.intervention_reason="خسائر مفتوحة: $"+DoubleToString(data.total_loss,2);
      }
      
      string aiCheck=GetAIBalanceRecommendation();
      if(StringFind(aiCheck,"INTERVENE")>=0){Print("🤖 orioto.ai يوصي بالتدخل الفوري");ForceIntervention();return;}
      if(StringFind(aiCheck,"FORCE_BALANCE")>=0){Print("🤖 orioto.ai: فرض موازنة فورية");ExecuteBalance(data);return;}
      
      if(EXCEPT_Enable&&CheckExceptionalConditions()){ExecuteExceptional();return;}
      
      if(shouldActivateUltra&&data.data_valid&&data.needs_intervention){
         EventChartCustom(0,EVENT_ULTRA_BALANCE_TRIGGERED,0,data.total_loss,"");
         ExecuteBalance(data);
      }
   }
   
   static void CloseUltraPositions(string type,string reason){
       for(int i=PositionsTotal()-1;i>=0;i--){
           if(!position.SelectByIndex(i))continue;
           string comment=position.Comment();
           bool shouldClose=false;
           if(type=="ALL"&&StringFind(comment,"ULTRA_")>=0)shouldClose=true;
           else if(type=="EXCEPTIONAL"&&StringFind(comment,"ULTRA_EXCEPTIONAL")>=0)shouldClose=true;
           else if(type=="NORMAL"&&StringFind(comment,"ULTRA_BALANCE")>=0&&StringFind(comment,"EXCEPTIONAL")<0)shouldClose=true;
           if(shouldClose)trade.PositionClose(position.Ticket());
       }
       Print("⛔ إغلاق ",type,": ",reason);
   }
   
   static string GetAIBalanceRecommendation(){
      if(AI_Mode==AI_OFF||AITradingSystem::apiKey=="")return "";
      string prompt="ULTRA BALANCE CHECK M1M5:\nTotal Loss: $"+DoubleToString(g_LastLossAmount,2)+"\nConsecutive Losses: "+IntegerToString(ConsecutiveLosses)+"\nPortfolio Health: "+DoubleToString(g_PortfolioHealth.score,1)+"%\nCurrent Positions: "+IntegerToString(PositionsTotal())+"\nSession: "+g_CurrentSession+"\nM1 Trend: "+AITradingSystem::GetM1Analysis()+"\nM5 Trend: "+AITradingSystem::GetM5Analysis()+"\n\nShould I INTERVENE now or WAIT? If intervene, suggest LOT size.";
      return AITradingSystem::CallOriotoAPIWithRetry(prompt,true);
   }
   
   static void ForceIntervention(){
      if(TimeCurrent()-last_force_intervention<15)return;
      last_force_intervention=TimeCurrent();
      operation_in_progress=true;
      operation_start_time=TimeCurrent();
      
      int bestDirection=AITradingSystem::GetSmartDirectionM1M5();
      if(bestDirection==0)bestDirection=GetSimpleDirection();
      if(bestDirection==0&&mainTrend!=0){
         bestDirection=mainTrend;
         Print("⚡ استخدام آخر اتجاه معروف: ",bestDirection>0?"شراء":"بيع");
      }
      
      double smartLot=CalculateLotSize()*2.0;
      string comment="ULTRA_AI_FORCE";
      
      if(bestDirection!=0){
         ENUM_ORDER_TYPE type=bestDirection>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
         if(OpenTrade(type,smartLot,comment)){
            balance_trades_count++;
            Print("🤖 orioto.ai تدخل فوري: ",comment);
         }
      }else Print("⚠️ لا يمكن تحديد الاتجاه - انتظار إشارة واضحة");
      operation_in_progress=false;
   }
   
   static bool CheckExceptionalConditions(){
      if(TimeCurrent()-last_exceptional_trade<EXCEPT_Cooldown)return false;
      
      int normalPositions=0;double totalLoss=0;
      for(int i=0;i<PositionsTotal();i++){
         if(!position.SelectByIndex(i)||position.Magic()!=ADVANCED_MagicNumber||position.Symbol()!=_Symbol||StringFind(position.Comment(),"ULTRA_")>=0)continue;
         normalPositions++;double pnl=position.Profit()+position.Swap()+position.Commission();
         if(pnl<0)totalLoss+=MathAbs(pnl);
      }
      
      bool condition1=normalPositions>=RISK_MaxTrades&&totalLoss>=EXCEPT_MinLoss;
      bool condition2=normalPositions>=RISK_MaxTrades/2&&totalLoss>=EXCEPT_MinLoss*1.5;
      bool condition3=ConsecutiveLosses>=3&&totalLoss>=EXCEPT_MinLoss/2;
      bool condition4=g_PortfolioHealth.score<50&&totalLoss>0;
      
      if(condition1||condition2||condition3||condition4){
         Print("🌟 شروط الصفقات الاستثنائية متحققة!");
         if(condition1)Print("   - الشرط 1: صفقات=",normalPositions," خسارة=$",DoubleToString(totalLoss,2));
         if(condition2)Print("   - الشرط 2: نصف الصفقات مع خسارة أكبر");
         if(condition3)Print("   - الشرط 3: خسائر متتالية=",ConsecutiveLosses);
         if(condition4)Print("   - الشرط 4: صحة المحفظة=",DoubleToString(g_PortfolioHealth.score,1),"%");
         return true;
      }
      return false;
   }
   
   static void ExecuteExceptional(){
      operation_in_progress=true;operation_start_time=TimeCurrent();
      PortfolioData data=AnalyzePortfolio();
      double lot=data.optimal_lot*EXCEPT_Multiplier;lot=MathMin(lot,ULTRA_MaxBalanceLot*1.5);
      string comment=StringFormat("ULTRA_EXCEPTIONAL_%d",exceptional_trades_count+1);
      ENUM_ORDER_TYPE type=data.smart_direction>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
      if(OpenTrade(type,lot,comment)){
         exceptional_trades_count++;last_exceptional_trade=TimeCurrent();
         Print("🌟 صفقة استثنائية:",comment);
         Print("📊 إجمالي الصفقات الاستثنائية: ",exceptional_trades_count);
      }
      operation_in_progress=false;
   }
   
   static PortfolioData AnalyzePortfolio(){
      PortfolioData data={};
      for(int i=0;i<PositionsTotal();i++){
         if(!position.SelectByIndex(i)||position.Magic()!=ADVANCED_MagicNumber||position.Symbol()!=_Symbol||StringFind(position.Comment(),"ULTRA_")>=0)continue;
         double pnl=position.Profit()+position.Swap()+position.Commission();
         data.total_positions++;
         if(pnl<0)data.total_loss+=MathAbs(pnl);
      }
      
      if(g_ForceRecovery.totalLossAmount>0){
         data.total_loss=MathMax(data.total_loss,g_ForceRecovery.totalLossAmount);
         data.data_valid=true;
      }
      
      data.needs_intervention=data.total_loss>=ULTRA_MinLossToBalance;
      
      if(data.needs_intervention){
         data.smart_direction=GetSmartDirection();
         if(data.smart_direction==0)data.smart_direction=GetSimpleDirection();
         data.required_profit=data.total_loss*ULTRA_BalanceMultiplier;
         data.optimal_lot=CalculateBalanceLot(data.required_profit);
         data.intervention_reason=StringFormat("خسائر $%.2f",data.total_loss);
      }
      
      return data;
   }
   
   static int GetSmartDirection(){
      if(!ULTRA_UseAllSystems)return GetIndicatorSignal();
      int direction=AITradingSystem::GetSmartDirectionM1M5();
      if(direction!=0)return direction;
      return GetSimpleDirection();
   }
   
   static int GetSimpleDirection(){
      double ma_fast[],ma_slow[];
      if(CopyBuffer(h_MA_Fast,0,0,2,ma_fast)==2&&CopyBuffer(h_MA_Slow,0,0,2,ma_slow)==2){
         if(ma_fast[1]>ma_slow[1]&&GetCurrentADX()>ULTRA_MinADXForEntry)return 1;
         if(ma_fast[1]<ma_slow[1]&&GetCurrentADX()>ULTRA_MinADXForEntry)return -1;
      }
      return 0;
   }
   
   static double CalculateBalanceLot(double required){
      double pip_value=GetPipValue(1.0);
      if(pip_value<=0){
         Logger::LogError("CalculateBalanceLot","pip_value is zero or negative");
         return SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
      }
      
      double lot=required/(ULTRA_MinProfitPips*pip_value);
      
      double balance=AccountInfoDouble(ACCOUNT_BALANCE);
      double maxRiskLot=balance*0.02/(TARGET_StopLoss*pip_value);
      
      lot=MathMin(lot,maxRiskLot);
      lot=MathMin(lot,ULTRA_MaxBalanceLot);
      return NormalizeLot(lot);
   }
   
   static void ExecuteBalance(PortfolioData&data){
      static datetime last_balance_trade=0;
      if(TimeCurrent()-last_balance_trade<300){
         Print("⏳ انتظار 300 ثانية قبل صفقة الموازنة التالية");
         return;
      }
      
      if(data.smart_direction==0){
         Print("⚠️ لا يمكن تحديد اتجاه السوق للموازنة");
         return;
      }
      
      operation_in_progress=true;
      operation_start_time=TimeCurrent();
      ENUM_ORDER_TYPE type=data.smart_direction>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
      string comment=StringFormat("ULTRA_BALANCE_%d",balance_trades_count+1);
      
      if(OpenTrade(type,data.optimal_lot,comment)){
         balance_trades_count++;last_balance_trade=TimeCurrent();
         Print("✅ موازنة فورية:",comment," لتعويض خسارة $",DoubleToString(data.total_loss,2));
         Print("📊 إجمالي صفقات الموازنة: ",balance_trades_count);
      }
      operation_in_progress=false;
   }
};

bool UltraBalance::operation_in_progress=false;
int UltraBalance::balance_trades_count=0,UltraBalance::exceptional_trades_count=0;
datetime UltraBalance::last_exceptional_trade=0,UltraBalance::last_force_intervention=0,UltraBalance::operation_start_time=0;

const int UltraBalance::OPERATION_TIMEOUT=30;

class HFTSystem{
public:
   static MqlTick tick_buffer[256];
   static int buffer_index;
   static const int BUFFER_SIZE;
   
   static void CheckSignals(){
      if(!HFT_Enable||dailyHFTCount>=HFT_MaxDaily||TimeCurrent()-lastHFTTrade<HFT_WaitSeconds)return;
      if(!RiskMonitor::CanOpenNewTrade())return;
      SafeHFTData data=AnalyzeHFT();
      if(data.isValid&&data.shouldEnter){
         g_LastHFTData=data;ENUM_ORDER_TYPE type=data.direction>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
         if(OpenTrade(type,data.suggestedLot,"HFT_"+data.pattern)){
            dailyHFTCount++;lastHFTTrade=TimeCurrent();
            EventChartCustom(0,EVENT_HFT_SIGNAL,data.direction,data.confidence,"");
            Logger::LogTrade("HFT",type,data.suggestedLot,type==ORDER_TYPE_BUY?Ask:Bid,data.pattern);
         }
      }
   }
   
   static SafeHFTData AnalyzeHFT(){
      SafeHFTData data={};
      MqlTick tick;
      if(!SymbolInfoTick(_Symbol,tick))return data;
      
      buffer_index=(buffer_index+1)%BUFFER_SIZE;
      tick_buffer[buffer_index]=tick;
      
      data.spread=(tick.ask-tick.bid)/g_Point;
      if(data.spread>2500)return data;
      
      if(buffer_index<10)return data;
      
      double sumVelocity=0,sumMomentum1s=0,sumMomentum5s=0;
      int count1s=0,count5s=0;
      
      int maxChecks=MathMin(buffer_index,50);
      int maxValid=20;
      
      for(int i=1;i<maxChecks&&(count1s<maxValid||count5s<maxValid);i++){
         int idx=(buffer_index-i+BUFFER_SIZE)%BUFFER_SIZE;
         int prev_idx=(buffer_index-i-1+BUFFER_SIZE)%BUFFER_SIZE;
         
         if(tick_buffer[idx].time==0||tick_buffer[prev_idx].time==0)continue;
         
         double time_diff=(double)(tick_buffer[idx].time-tick_buffer[prev_idx].time);
         if(time_diff<=0||time_diff>60)continue;
         
         double price_diff=tick_buffer[idx].bid-tick_buffer[prev_idx].bid;
         double velocity=price_diff/g_Point/time_diff;
         
         if(time_diff<=1&&count1s<maxValid){
            sumMomentum1s+=velocity;
            count1s++;
         }
         if(time_diff<=5&&count5s<maxValid){
            sumMomentum5s+=velocity;
            count5s++;
         }
      }
      
      if(count1s>0)data.momentum1s=sumMomentum1s/count1s;
      if(count5s>0)data.momentum5s=sumMomentum5s/count5s;
      data.velocity=MathAbs(data.momentum1s);
      
      long totalVolume=0,recentVolume=0;
      for(int i=0;i<MathMin(maxChecks,50);i++){
         int idx=(buffer_index-i+BUFFER_SIZE)%BUFFER_SIZE;
         if(tick_buffer[idx].time==0)continue;
         long tickVolume=(long)tick_buffer[idx].volume;
         totalVolume+=tickVolume;
         if(i<10)recentVolume+=tickVolume;
      }
      if(totalVolume>0)data.volumeStrength=(double)recentVolume*5.0/(double)totalVolume;
      
      double maxGap=0;
      for(int i=1;i<MathMin(maxChecks,10);i++){
         int idx=(buffer_index-i+BUFFER_SIZE)%BUFFER_SIZE;
         int prev_idx=(buffer_index-i-1+BUFFER_SIZE)%BUFFER_SIZE;
         if(tick_buffer[idx].time==0||tick_buffer[prev_idx].time==0)continue;
         double gap=MathAbs(tick_buffer[idx].bid-tick_buffer[prev_idx].bid)/g_Point;
         if(gap>maxGap)maxGap=gap;
      }
      data.gapAnalysis=maxGap;
      
      if(MathAbs(data.momentum1s)>10&&data.volumeStrength>BOOST_VolumeRatioMin){
         data.direction=data.momentum1s>0?1:-1;
         data.confidence=60+MathMin(30,MathAbs(data.momentum1s));
         data.pattern=data.volumeStrength>2?"HIGH_VOLUME":"MOMENTUM";
         if(HFT_UseUltraPrediction&&g_LastUSTPPrediction.direction==data.direction){
            data.confidence=MathMin(95,(data.confidence+g_LastUSTPPrediction.confidence)/2*1.1);
            data.pattern+="_USTP";
         }
         if(data.confidence>=HFT_MinConfidence){
            data.shouldEnter=true;
            data.suggestedLot=CalculateLotSize()*0.8;
            data.suggestedTP=TARGET_TakeProfit;
            data.suggestedSL=TARGET_StopLoss;
            data.isValid=true;
         }
      }
      return data;
   }
};

MqlTick HFTSystem::tick_buffer[256];
int HFTSystem::buffer_index=0;
const int HFTSystem::BUFFER_SIZE=256;

class VolumeBoostSystem{
public:
   static void UpdateSignal(){
      if(!BOOST_Enable||dailyBoostTrades>=BOOST_MaxDailyTrades){g_BoostSignal.active=false;return;}
      if(TimeCurrent()<g_BoostSignal.validUntil&&g_BoostSignal.active)return;
      int confirmations=0,totalDirection=0;double totalConfidence=0;string reasons="";
      if(g_LastUSTPPrediction.direction!=0&&TimeCurrent()<g_LastUSTPPrediction.validUntil){totalDirection+=g_LastUSTPPrediction.direction;totalConfidence+=g_LastUSTPPrediction.confidence;confirmations++;reasons="USTP";}
      double adx=GetCurrentADX();
      if(adx>=BOOST_MinADX&&mainTrend!=0){totalDirection+=mainTrend;totalConfidence+=adx*2;confirmations++;if(reasons!="")reasons+=" + ";reasons+="ADX_"+DoubleToString(adx,1);}
      double volumeRatio=GetVolumeRatio();
      if(volumeRatio>BOOST_VolumeRatioMin){confirmations++;totalConfidence+=70+(volumeRatio-BOOST_VolumeRatioMin)*20;if(reasons!="")reasons+=" + ";reasons+="VOL_"+DoubleToString(volumeRatio,2)+"x";}
      if(g_LastHFTData.isValid&&g_LastHFTData.confidence>70){totalDirection+=g_LastHFTData.direction;totalConfidence+=g_LastHFTData.confidence;confirmations++;if(reasons!="")reasons+=" + ";reasons+="HFT";}
      bool enough=BOOST_RequireMultiConfirm?(confirmations>=3):(confirmations>=2);
      double avgConfidence=confirmations>0?totalConfidence/confirmations:0;
      if(enough&&MathAbs(totalDirection)>=confirmations-1&&avgConfidence>=BOOST_MinConfidence){
         g_BoostSignal.active=true;g_BoostSignal.direction=totalDirection>0?1:-1;g_BoostSignal.confidence=avgConfidence;
         g_BoostSignal.validUntil=TimeCurrent()+300;g_BoostSignal.suggestedMultiplier=BOOST_Multiplier;
         g_BoostSignal.reason=reasons;g_BoostSignal.volumeRatio=volumeRatio;g_BoostSignal.confirmations=confirmations;
         Print("🚀 إشارة رفع الحجم! تأكيدات:",confirmations," ثقة:",DoubleToString(avgConfidence,1),"%");
         EventChartCustom(0,EVENT_BOOST_SIGNAL,g_BoostSignal.direction,avgConfidence,"");
      }else g_BoostSignal.active=false;
   }
   
   static double GetVolumeRatio(){
      long volumes[];ArrayResize(volumes,50);
      if(CopyTickVolume(_Symbol,MARKET_Timeframe,0,50,volumes)<50)return 1.0;
      long recent=0,total=0;
      for(int i=0;i<50;i++){total+=volumes[i];if(i<5)recent+=volumes[i];}
      return total>0?(double)recent*10.0/(double)total:1.0;
   }
   
   static double ApplyBoost(double baseLot,string&comment){
      if(!g_BoostSignal.active)return baseLot;
      double boosted=baseLot*g_BoostSignal.suggestedMultiplier;boosted=MathMin(boosted,BOOST_MaxLot);
      if(comment!="")comment+="_";comment+="BOOST_"+IntegerToString((int)g_BoostSignal.confidence);
      dailyBoostTrades++;return boosted;
   }
};

class TurboSystem{
public:
   static void UpdateSignal(){
      if(!TURBO_Enable){g_TurboSignal.active=false;return;}
      double adx=GetCurrentADX();
      if(TURBO_UseMultiTimeframe){double adx_m5=GetADXTimeframe(PERIOD_M5),adx_m15=GetADXTimeframe(PERIOD_M15);adx=(adx+adx_m5+adx_m15)/3;}
      if(adx>=TURBO_MinTrend&&mainTrend!=0){
         monitoredTurboDirection=mainTrend;monitoredTurboConfidence=adx;
         if(TimeCurrent()-lastTurboTrade>=TURBO_WaitSeconds){
            g_TurboSignal.active=true;g_TurboSignal.direction=monitoredTurboDirection;g_TurboSignal.confidence=monitoredTurboConfidence;
            g_TurboSignal.adxStrength=adx;g_TurboSignal.aggressiveMode=adx>=TURBO_StrongTrendADX;
            g_TurboSignal.suggestedMultiplier=g_TurboSignal.aggressiveMode?TURBO_AggressiveMultiplier:TURBO_Multiplier;
            EventChartCustom(0,EVENT_TURBO_SIGNAL,mainTrend,adx,"");
         }
      }else{
         g_TurboSignal.active=false;
         if(adx<TURBO_MinTrend*0.8){monitoredTurboDirection=0;monitoredTurboConfidence=0;}
      }
   }
   
   static double GetADXTimeframe(ENUM_TIMEFRAMES tf){
      int handle=iADX(_Symbol,tf,14);if(handle==INVALID_HANDLE)return 0;
      double adx[];if(CopyBuffer(handle,0,0,1,adx)==1){IndicatorRelease(handle);return adx[0];}
      IndicatorRelease(handle);return 0;
   }
   
   static void OnTradeExecuted(){lastTurboTrade=TimeCurrent();monitoredTurboDirection=0;monitoredTurboConfidence=0;}
};

class ForceSystem{
public:
   static void UpdateSignal(){
      if(!FORCE_Enable)return;
      if(ConsecutiveLosses>=FORCE_AfterLosses){
         g_ForceRecovery.recoveryMultiplier=FORCE_Multiplier;
         if(g_ForceRecovery.totalLossAmount>=FORCE_EmergencyLossLevel){
            g_ForceRecovery.emergencyMode=true;g_ForceRecovery.recoveryMultiplier=FORCE_RecoveryMultiplier*1.5;
         }
         g_ForceRecovery.confidence=MathMin(90,60+ConsecutiveLosses*5);
         int direction=GetDirection();
         if(direction!=0){monitoredForceDirection=direction;monitoredForceConfidence=g_ForceRecovery.confidence;}
         EventChartCustom(0,EVENT_FORCE_SIGNAL,1,g_ForceRecovery.confidence,"");
      }else{
         g_ForceRecovery.emergencyMode=false;g_ForceRecovery.confidence=0;
         if(ConsecutiveLosses==0){monitoredForceDirection=0;monitoredForceConfidence=0;}
      }
   }
   
   static int GetDirection(){
      int signal=GetIndicatorSignal();if(signal!=0)return signal;
      if(g_TurboSignal.active)return g_TurboSignal.direction;
      if(g_BoostSignal.active)return g_BoostSignal.direction;
      if(g_LastUSTPPrediction.direction!=0)return g_LastUSTPPrediction.direction;
      return 0;
   }
   
   static bool CanTrade(){return TimeCurrent()-lastForceTrade>=FORCE_WaitSeconds;}
   static void OnTradeExecuted(){lastForceTrade=TimeCurrent();monitoredForceDirection=0;monitoredForceConfidence=0;}
};

class RangeSystem{
public:
   struct BreakoutData{bool detected,retested;int direction;double breakLevel,volumeAtBreak;datetime breakTime;};
   static BreakoutData breakout;
   static double rangeATR;
   static bool rangeActive;
   static datetime rangeStartTime;
   static int barsInRange;
   
   static void UpdateRange(){
      if(!RANGE_Enable)return;
      double high[],low[],close[];
      if(CopyHigh(_Symbol,MARKET_Timeframe,0,RANGE_Periods,high)<RANGE_Periods||CopyLow(_Symbol,MARKET_Timeframe,0,RANGE_Periods,low)<RANGE_Periods||CopyClose(_Symbol,MARKET_Timeframe,0,RANGE_Periods,close)<RANGE_Periods){currentRange.isValid=false;return;}
      double atr[];if(CopyBuffer(h_ATR,0,0,1,atr)==1)rangeATR=atr[0];
      currentRange.high=high[ArrayMaximum(high)];currentRange.low=low[ArrayMinimum(low)];currentRange.size=(currentRange.high-currentRange.low)/g_Point;
      bool sizeValid=currentRange.size>=RANGE_MinSize&&currentRange.size<=RANGE_MinSize*3;
      bool atrValid=rangeATR>0&&currentRange.size>rangeATR/g_Point*0.5;
      int touchesHigh=0,touchesLow=0;
      for(int i=0;i<RANGE_Periods;i++){
         if(high[i]>=currentRange.high-5*g_Point)touchesHigh++;
         if(low[i]<=currentRange.low+5*g_Point)touchesLow++;
      }
      bool wellTested=(touchesHigh>=2&&touchesLow>=2);
      currentRange.isValid=sizeValid&&atrValid&&wellTested;
      if(currentRange.isValid){
         currentRange.quality=60;if(wellTested)currentRange.quality+=20;
         if(currentRange.size<RANGE_MinSize*1.5)currentRange.quality+=10;
         if(rangeATR>0&&currentRange.size<rangeATR/g_Point*2)currentRange.quality+=10;
         currentRange.confidence=currentRange.quality;barsInRange++;
         if(RANGE_UseFibonacci){
            double range=currentRange.high-currentRange.low;
            currentRange.fibo382Level=currentRange.low+range*RANGE_Fibo382;
            currentRange.fibo618Level=currentRange.low+range*RANGE_Fibo618;
         }
         if(!rangeActive){rangeActive=true;rangeStartTime=TimeCurrent();}
         DetectBreakout(close[0]);
      }else{rangeActive=false;barsInRange=0;breakout.detected=false;breakout.retested=false;}
   }
   
   static void DetectBreakout(double currentPrice){
      if(currentPrice>currentRange.high&&!breakout.detected){
         breakout.detected=true;breakout.direction=1;breakout.breakLevel=currentRange.high;
         breakout.breakTime=TimeCurrent();breakout.volumeAtBreak=GetCurrentVolume();breakout.retested=false;
         monitoredRangeDirection=1;monitoredRangeConfidence=currentRange.confidence;
      }
      else if(currentPrice<currentRange.low&&!breakout.detected){
         breakout.detected=true;breakout.direction=-1;breakout.breakLevel=currentRange.low;
         breakout.breakTime=TimeCurrent();breakout.volumeAtBreak=GetCurrentVolume();breakout.retested=false;
         monitoredRangeDirection=-1;monitoredRangeConfidence=currentRange.confidence;
      }
      if(breakout.detected&&!breakout.retested){
         if(breakout.direction>0&&currentPrice<=breakout.breakLevel+10*g_Point)breakout.retested=true;
         else if(breakout.direction<0&&currentPrice>=breakout.breakLevel-10*g_Point)breakout.retested=true;
      }
   }
   
   static double GetCurrentVolume(){long volumes[];ArrayResize(volumes,1);if(CopyTickVolume(_Symbol,MARKET_Timeframe,0,1,volumes)==1)return (double)volumes[0];return 0;}
   
   static int GetSignal(){
      if(!currentRange.isValid||!breakout.detected)return 0;
      if(TimeCurrent()-lastRangeTrade<RANGE_WaitSeconds)return 0;
      MqlDateTime time;TimeToStruct(TimeCurrent(),time);
      if(time.hour<RANGE_StartHour||time.hour>RANGE_EndHour)return 0;
      if(RANGE_RequireRetest&&!breakout.retested)return 0;
      if(TimeCurrent()-breakout.breakTime<60)return 0;
      double currentPrice=SymbolInfoDouble(_Symbol,SYMBOL_BID);
      double breakDistance=breakout.direction>0?(currentPrice-breakout.breakLevel)/g_Point:(breakout.breakLevel-currentPrice)/g_Point;
      if(breakDistance<RANGE_MinBreakDistance)return 0;
      int confirmations=0;
      if(RANGE_UseVolumeFilter){double currentVolume=GetCurrentVolume();if(currentVolume>breakout.volumeAtBreak*RANGE_VolumeMultiplier)confirmations++;}
      if(GetCurrentADX()>25&&mainTrend==breakout.direction)confirmations++;
      if(g_TurboSignal.active&&g_TurboSignal.direction==breakout.direction)confirmations++;
      if(g_LastUSTPPrediction.direction==breakout.direction)confirmations++;
      double rsi[];if(CopyBuffer(h_RSI,0,0,1,rsi)==1){
         if(breakout.direction>0&&rsi[0]>50&&rsi[0]<70)confirmations++;
         else if(breakout.direction<0&&rsi[0]<50&&rsi[0]>30)confirmations++;
      }
      if(confirmations>=RANGE_MinConfirmations){
         currentRange.isValid=false;breakout.detected=false;
         EventChartCustom(0,EVENT_RANGE_SIGNAL,breakout.direction,confirmations*25,"BREAKOUT");
         return monitoredRangeDirection;
      }
      return 0;
   }
   
   static void OnTradeExecuted(){
      lastRangeTrade=TimeCurrent();monitoredRangeDirection=0;monitoredRangeConfidence=0;
      breakout.detected=false;breakout.retested=false;
   }
};


RangeSystem::BreakoutData RangeSystem::breakout;
double RangeSystem::rangeATR=0;
bool RangeSystem::rangeActive=false;
datetime RangeSystem::rangeStartTime=0;
int RangeSystem::barsInRange=0;

class ScalpingSystem{
public:
   static void UpdateSignal(){
      if(!SCALP_Enable||dailyScalpingTrades>=SCALP_MaxDailyTrades){
         g_ScalpingSignal.active=false;
         if(!SCALP_Enable){monitoredScalpingDirection=0;monitoredScalpingConfidence=0;}
         return;
      }
      
      double bbUpper[],bbMiddle[],bbLower[];
      ArraySetAsSeries(bbUpper,true);ArraySetAsSeries(bbMiddle,true);ArraySetAsSeries(bbLower,true);
      if(CopyBuffer(h_BollingerBands,0,0,3,bbUpper)<3||CopyBuffer(h_BollingerBands,1,0,3,bbMiddle)<3||CopyBuffer(h_BollingerBands,2,0,3,bbLower)<3)return;
      double current=SymbolInfoDouble(_Symbol,SYMBOL_BID);
      bool nearUpper=(current>=bbUpper[0]-10*g_Point),nearLower=(current<=bbLower[0]+10*g_Point);
      
      if(nearUpper){
         monitoredScalpingDirection=-1;monitoredScalpingConfidence=80;
         if(TimeCurrent()-lastScalpingTrade>=SCALP_WaitSeconds){
            g_ScalpingSignal.active=true;g_ScalpingSignal.direction=monitoredScalpingDirection;g_ScalpingSignal.confidence=monitoredScalpingConfidence;
            g_ScalpingSignal.pattern="BB_UPPER";g_ScalpingSignal.entryPrice=current;g_ScalpingSignal.targetPrice=bbMiddle[0];
            EventChartCustom(0,EVENT_SCALPING_SIGNAL,-1,80,"");
         }
      }else if(nearLower){
         monitoredScalpingDirection=1;monitoredScalpingConfidence=80;
         if(TimeCurrent()-lastScalpingTrade>=SCALP_WaitSeconds){
            g_ScalpingSignal.active=true;g_ScalpingSignal.direction=monitoredScalpingDirection;g_ScalpingSignal.confidence=monitoredScalpingConfidence;
            g_ScalpingSignal.pattern="BB_LOWER";g_ScalpingSignal.entryPrice=current;g_ScalpingSignal.targetPrice=bbMiddle[0];
            EventChartCustom(0,EVENT_SCALPING_SIGNAL,1,80,"");
         }
      }else{
         g_ScalpingSignal.active=false;
         if(current>bbLower[0]+50*g_Point&&current<bbUpper[0]-50*g_Point){monitoredScalpingDirection=0;monitoredScalpingConfidence=0;}
      }
   }
   
   static void OnTradeExecuted(){lastScalpingTrade=TimeCurrent();monitoredScalpingDirection=0;monitoredScalpingConfidence=0;}
};

class Protection{
public:
   static bool active;
   static datetime end_time;
   static double starting_balance,highest_balance;
   
   static void Initialize(){starting_balance=AccountInfoDouble(ACCOUNT_BALANCE);highest_balance=starting_balance;}
   
   static bool Check(){
      if(active&&TimeCurrent()>=end_time){active=false;protectionActive=false;Print("✅ انتهت فترة الحماية");}
      if(active)return false;
      double balance=AccountInfoDouble(ACCOUNT_BALANCE),equity=AccountInfoDouble(ACCOUNT_EQUITY);
      if(balance>highest_balance)highest_balance=balance;
      if(PROTECT_DrawdownEnable){
         double drawdown=((starting_balance-equity)/starting_balance)*100;
         if(drawdown>=DD_MaxPercent){Activate("تراجع "+DoubleToString(drawdown,1)+"%",DD_StopMinutes);return false;}
      }
      if(PROTECT_MarginEnable){
         double margin_level=AccountInfoDouble(ACCOUNT_MARGIN_LEVEL);
         if(margin_level>0&&margin_level<MARGIN_MinLevel){Activate("هامش منخفض "+DoubleToString(margin_level,1)+"%",60);return false;}
      }
      if(PROTECT_VelocityEnable){
         static double velocity_start=balance;static datetime velocity_time=TimeCurrent();
         if(TimeCurrent()-velocity_time<VELOCITY_TimeFrame*60){
            double loss=velocity_start-balance;
            if(loss>=VELOCITY_MaxLossAmount){Activate("خسارة سريعة $"+DoubleToString(loss,2),45);return false;}
         }else{velocity_start=balance;velocity_time=TimeCurrent();}
      }
      return true;
   }
   
   static void Activate(string reason,int minutes){
      if(AI_Mode!=AI_OFF&&AI_FullControl){Print("🔔 محاولة تفعيل الحماية: ",reason);Print("🤖 AI له الصلاحية للتجاوز إذا كانت الظروف ممتازة");}
      active=true;end_time=TimeCurrent()+minutes*60;Print("🚨 تفعيل الحماية:",reason);
      protectionActive=true;protectionEndTime=end_time;
   }
};

bool Protection::active=false;
datetime Protection::end_time=0;
double Protection::starting_balance=0,Protection::highest_balance=0;

void InitializeSymbol(){
   g_Digits=(int)SymbolInfoInteger(_Symbol,SYMBOL_DIGITS);g_Point=SymbolInfoDouble(_Symbol,SYMBOL_POINT);
   g_IsGold=StringFind(_Symbol,"XAUUSD")>=0||StringFind(_Symbol,"GOLD")>=0;
   g_IsCrypto=StringFind(_Symbol,"BTC")>=0||StringFind(_Symbol,"ETH")>=0;
   g_PipValue=g_IsGold?0.1:(g_IsCrypto?1.0:g_Point*10);symbol_info.Name(_Symbol);
}

bool InitializeIndicators(){
   h_MA_Fast=iMA(_Symbol,MARKET_Timeframe,9,0,MODE_EMA,PRICE_CLOSE);
   h_MA_Slow=iMA(_Symbol,MARKET_Timeframe,21,0,MODE_EMA,PRICE_CLOSE);
   h_RSI=iRSI(_Symbol,MARKET_Timeframe,14,PRICE_CLOSE);
   h_ATR=iATR(_Symbol,MARKET_Timeframe,14);
   h_ADX=iADX(_Symbol,MARKET_Timeframe,14);
   h_MACD=iMACD(_Symbol,MARKET_Timeframe,12,26,9,PRICE_CLOSE);
   h_BollingerBands=iBands(_Symbol,MARKET_Timeframe,SCALP_BBPeriod,0,SCALP_BBDeviation,PRICE_CLOSE);
   h_MA_Fast_M5=iMA(_Symbol,MARKET_SecondaryTimeframe,9,0,MODE_EMA,PRICE_CLOSE);
   h_MA_Slow_M5=iMA(_Symbol,MARKET_SecondaryTimeframe,21,0,MODE_EMA,PRICE_CLOSE);
   h_RSI_M5=iRSI(_Symbol,MARKET_SecondaryTimeframe,14,PRICE_CLOSE);
   h_ATR_M5=iATR(_Symbol,MARKET_SecondaryTimeframe,14);
   h_ADX_M5=iADX(_Symbol,MARKET_SecondaryTimeframe,14);
   return h_MA_Fast!=INVALID_HANDLE&&h_MA_Slow!=INVALID_HANDLE&&h_RSI!=INVALID_HANDLE&&h_ATR!=INVALID_HANDLE&&h_ADX!=INVALID_HANDLE&&h_MACD!=INVALID_HANDLE&&h_BollingerBands!=INVALID_HANDLE&&h_MA_Fast_M5!=INVALID_HANDLE&&h_MA_Slow_M5!=INVALID_HANDLE;
}

void ReleaseIndicators(){
   if(h_MA_Fast!=INVALID_HANDLE)IndicatorRelease(h_MA_Fast);
   if(h_MA_Slow!=INVALID_HANDLE)IndicatorRelease(h_MA_Slow);
   if(h_RSI!=INVALID_HANDLE)IndicatorRelease(h_RSI);
   if(h_ATR!=INVALID_HANDLE)IndicatorRelease(h_ATR);
   if(h_ADX!=INVALID_HANDLE)IndicatorRelease(h_ADX);
   if(h_MACD!=INVALID_HANDLE)IndicatorRelease(h_MACD);
   if(h_BollingerBands!=INVALID_HANDLE)IndicatorRelease(h_BollingerBands);
   if(h_MA_Fast_M5!=INVALID_HANDLE)IndicatorRelease(h_MA_Fast_M5);
   if(h_MA_Slow_M5!=INVALID_HANDLE)IndicatorRelease(h_MA_Slow_M5);
   if(h_RSI_M5!=INVALID_HANDLE)IndicatorRelease(h_RSI_M5);
   if(h_ATR_M5!=INVALID_HANDLE)IndicatorRelease(h_ATR_M5);
   if(h_ADX_M5!=INVALID_HANDLE)IndicatorRelease(h_ADX_M5);
}

void ResetDailyCounters(){
      datetime current_day = StringToTime(TimeToString(TimeCurrent(),TIME_DATE));
      if(LastDailyReset == current_day) return;

      dailyHFTCount=0;dailyUSTPCount=0;dailyBoostTrades=0;dailyTurboTrades=0;dailyForceTrades=0;dailyScalpingTrades=0;dailyIndicatorTrades=0;
      DailyStartBalance=AccountInfoDouble(ACCOUNT_BALANCE);LastDailyReset=current_day;
      lastTurboTrade=0;lastForceTrade=0;lastRangeTrade=0;lastScalpingTrade=0;lastIndicatorTrade=0;
      monitoredTurboDirection=0;monitoredForceDirection=0;monitoredRangeDirection=0;monitoredScalpingDirection=0;
      monitoredTurboConfidence=0;monitoredForceConfidence=0;monitoredRangeConfidence=0;monitoredScalpingConfidence=0;
      if(AI_Mode!=AI_OFF){AITradingSystem::dailyCalls=0;AITradingSystem::sessionWins=0;AITradingSystem::sessionLosses=0;AITradingSystem::sessionProfitLoss=0;AITradingSystem::maxDrawdownToday=0;}
      Print("📅 بداية يوم جديد - إعادة تعيين العدادات");
      Print("📊 Ultra Balance: ",UltraBalance::balance_trades_count," صفقة | Exceptional: ",UltraBalance::exceptional_trades_count," صفقة");
      Print("⏱️ تم إعادة تعيين جميع المؤقتات الزمنية ومتغيرات المراقبة");
}

double GetCurrentADX(){double adx[];if(CopyBuffer(h_ADX,0,0,1,adx)==1)return adx[0];return 0;}

int GetIndicatorSignal(){
   double ma_fast[],ma_slow[],rsi[];
   ArraySetAsSeries(ma_fast,true);ArraySetAsSeries(ma_slow,true);
   if(CopyBuffer(h_MA_Fast,0,0,2,ma_fast)<2||CopyBuffer(h_MA_Slow,0,0,2,ma_slow)<2||CopyBuffer(h_RSI,0,0,1,rsi)<1)return 0;
   
   int baseSignal=0;
   if(ma_fast[0]>ma_slow[0]&&ma_fast[1]<=ma_slow[1]&&rsi[0]>50)baseSignal=1;
   else if(ma_fast[0]<ma_slow[0]&&ma_fast[1]>=ma_slow[1]&&rsi[0]<50)baseSignal=-1;
   
   if(baseSignal==0)return 0;
   
   double adx=GetCurrentADX();
   if(adx<20)return 0;
   
   double ma_fast_m5[],ma_slow_m5[],rsi_m5[];
   ArraySetAsSeries(ma_fast_m5,true);ArraySetAsSeries(ma_slow_m5,true);ArraySetAsSeries(rsi_m5,true);
   
   if(CopyBuffer(h_MA_Fast_M5,0,0,1,ma_fast_m5)==1&&CopyBuffer(h_MA_Slow_M5,0,0,1,ma_slow_m5)==1&&CopyBuffer(h_RSI_M5,0,0,1,rsi_m5)==1){
      if(baseSignal==1){
         if(ma_fast_m5[0]<=ma_slow_m5[0]||rsi_m5[0]<45)return 0;
         if(adx>40&&ma_fast_m5[0]>ma_slow_m5[0]&&rsi_m5[0]>60)Print("💪 إشارة شراء قوية من الإنديكاتور - ADX: ",DoubleToString(adx,1));
      }else if(baseSignal==-1){
         if(ma_fast_m5[0]>=ma_slow_m5[0]||rsi_m5[0]>55)return 0;
         if(adx>40&&ma_fast_m5[0]<ma_slow_m5[0]&&rsi_m5[0]<40)Print("💪 إشارة بيع قوية من الإنديكاتور - ADX: ",DoubleToString(adx,1));
      }
   }
   
   double atr=GetATR();double avgRange=0;
   for(int i=1;i<=20;i++){
      double high=iHigh(_Symbol,MARKET_Timeframe,i),low=iLow(_Symbol,MARKET_Timeframe,i);
      avgRange+=(high-low);
   }
   avgRange/=20;
   
   if(atr>avgRange*2.5){
      Print("⚠️ تقلبات عالية جداً - تجنب إشارة الإنديكاتور");
      return 0;
   }
   
   return baseSignal;
}

void UpdateMainTrend(){
   double adx=GetCurrentADX();
   if(adx>25){
      double plus[],minus[];
      if(CopyBuffer(h_ADX,1,0,1,plus)==1&&CopyBuffer(h_ADX,2,0,1,minus)==1){
         if(plus[0]>minus[0]+5)mainTrend=1;else if(minus[0]>plus[0]+5)mainTrend=-1;else mainTrend=0;
      }
   }else mainTrend=0;
}

double GetPipValue(double lot){
   if(g_IsGold)return 0.1*lot;
   double tick_value=SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   if(tick_value>0)return tick_value*lot;
   return 0.1*lot;
}

double GetSpreadCost(){double spread=(Ask-Bid)/_Point;return spread*GetPipValue(1.0);}

double CalculateLotSize(){
   double baseLot=RISK_LotSize>0?RISK_LotSize:CalculateBaseLot();
   if(AI_Mode!=AI_OFF&&AITradingSystem::currentAnalysis.suggestedLotMultiplier>0){
      baseLot*=AITradingSystem::currentAnalysis.suggestedLotMultiplier;
      if(AITradingSystem::currentAnalysis.riskScore>70)baseLot*=0.7;
   }
   if(AITradingSystem::sessionLosses>AITradingSystem::sessionWins*2)baseLot*=0.5;
   else if(AITradingSystem::sessionWins>10&&AITradingSystem::sessionProfitLoss>0)baseLot*=1.2;
   return NormalizeLot(baseLot);
}

double CalculateBaseLot(){
   double balance=AccountInfoDouble(ACCOUNT_BALANCE),risk=balance*RISK_Percent/100.0,pip_value=GetPipValue(1.0);
   if(pip_value<=0){
      Logger::LogError("CalculateBaseLot","pip_value is zero or negative");
      return SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   }
   return risk/(TARGET_StopLoss*pip_value);
}

double NormalizeLot(double lot){
   double min_lot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN),max_lot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX),lot_step=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
   if(lot_step>0)lot=MathFloor(lot/lot_step)*lot_step;
   if(lot<min_lot)lot=min_lot;if(lot>max_lot)lot=max_lot;
   int digits=0;
   if(lot_step<1){
      if(lot_step>=0.1)digits=1;else if(lot_step>=0.01)digits=2;
      else if(lot_step>=0.001)digits=3;else digits=4;
   }
   return NormalizeDouble(lot,digits);
}

bool CheckActiveSystemsConflict(string newSystem){
   int activeSystems=0;
   if(g_TurboSignal.active)activeSystems++;
   if(g_BoostSignal.active)activeSystems++;
   if(g_ScalpingSignal.active)activeSystems++;
   if(g_ForceRecovery.emergencyMode)activeSystems++;
   if(g_LastUSTPPrediction.direction!=0&&TimeCurrent()<g_LastUSTPPrediction.validUntil)activeSystems++;
   
   if(activeSystems>=3){
      if(ADVANCED_EnableLogging)Print("⚠️ تضارب الأنظمة: ",activeSystems," أنظمة نشطة - تجنب ",newSystem);
      return true;
   }
   
   for(int i=0;i<10;i++){
      if(g_SystemActivity[i].isActive&&TimeCurrent()-g_SystemActivity[i].lastOpen<5){
         if(ADVANCED_EnableLogging)Print("⚠️ نظام آخر فتح صفقة منذ أقل من 5 ثواني");
         return true;
      }
   }
   
   return false;
}

void UpdateSystemActivity(int systemIndex){
   g_SystemActivity[systemIndex].lastOpen=TimeCurrent();
   g_SystemActivity[systemIndex].isActive=true;
   g_SystemActivity[systemIndex].tradesOpen++;
}

bool OpenTrade(ENUM_ORDER_TYPE type,double lot,string comment=""){
   if(!g_SystemInitialized||lot<=0)return false;
   if(!RiskMonitor::CanOpenNewTrade())return false;
   
   int systemIndex=-1;
   if(StringFind(comment,"TURBO")>=0)systemIndex=0;
   else if(StringFind(comment,"FORCE")>=0)systemIndex=1;
   else if(StringFind(comment,"HFT")>=0)systemIndex=2;
   else if(StringFind(comment,"USTP")>=0)systemIndex=3;
   else if(StringFind(comment,"BOOST")>=0)systemIndex=4;
   else if(StringFind(comment,"RANGE")>=0)systemIndex=5;
   else if(StringFind(comment,"SCALP")>=0)systemIndex=6;
   else if(StringFind(comment,"INDICATOR")>=0)systemIndex=7;
   else if(StringFind(comment,"AI")>=0)systemIndex=8;
   else if(StringFind(comment,"ULTRA")>=0)systemIndex=9;
   
   if(systemIndex>=0&&CheckActiveSystemsConflict(comment))return false;
   
   double requiredMargin;
   if(!OrderCalcMargin(type,_Symbol,lot,SymbolInfoDouble(_Symbol,type==ORDER_TYPE_BUY?SYMBOL_ASK:SYMBOL_BID),requiredMargin))return false;
   double freeMargin=AccountInfoDouble(ACCOUNT_MARGIN_FREE);
   if(requiredMargin>freeMargin*0.8){lot=NormalizeLot(lot*0.5);if(lot<SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN))return false;}
   if(!Protection::Check()&&(!AI_Mode!=AI_OFF||!AITradingSystem::dynamicSettings.protectionOverridden))return false;
   lot=VolumeBoostSystem::ApplyBoost(lot,comment);
   double originalLot=lot;lot=NormalizeLot(lot);
   if(AI_AutoFixVolume&&originalLot!=lot)Print("🔧 orioto.ai: تصحيح الحجم من ",DoubleToString(originalLot,2)," إلى ",DoubleToString(lot,2));
   double price=type==ORDER_TYPE_BUY?SymbolInfoDouble(_Symbol,SYMBOL_ASK):SymbolInfoDouble(_Symbol,SYMBOL_BID);
   
   int tp=TARGET_TakeProfit,sl=TARGET_StopLoss;
   double actualLot=lot;
   
   if(StringFind(comment,"TURBO")>=0){tp=TURBO_TP;sl=TURBO_SL;if(TURBO_LotSize>0)actualLot=TURBO_LotSize;}
   else if(StringFind(comment,"SCALP")>=0){tp=SCALP_QuickTP;sl=SCALP_QuickSL;if(SCALP_LotSize>0)actualLot=SCALP_LotSize;}
   else if(StringFind(comment,"RANGE")>=0){tp=RANGE_ScalpTP;sl=RANGE_ScalpSL;if(RANGE_LotSize>0)actualLot=RANGE_LotSize;}
   else if(StringFind(comment,"HFT")>=0&&g_LastHFTData.isValid){tp=g_LastHFTData.suggestedTP;sl=g_LastHFTData.suggestedSL;}
   else if(StringFind(comment,"FORCE")>=0){tp=FORCE_TP;sl=FORCE_SL;if(FORCE_LotSize>0)actualLot=FORCE_LotSize;}
   
   actualLot=NormalizeLot(actualLot);
   double tp_price=type==ORDER_TYPE_BUY?price+tp*g_Point:price-tp*g_Point;
   double sl_price=type==ORDER_TYPE_BUY?price-sl*g_Point:price+sl*g_Point;
   trade.SetExpertMagicNumber(ADVANCED_MagicNumber);trade.SetDeviationInPoints(MARKET_MaxSlippage);
   if(trade.PositionOpen(_Symbol,type,actualLot,price,sl_price,tp_price,comment)){
      LastTradeTime=TimeCurrent();
      if(systemIndex>=0)UpdateSystemActivity(systemIndex);
      Logger::LogTrade(comment,type,actualLot,price,"System trade");
      return true;
   }
   return false;
}

void UpdateTrailingStop(){
   if(!TARGET_UseTrailing)return;
   for(int i=0;i<PositionsTotal();i++){
      if(!position.SelectByIndex(i)||position.Magic()!=ADVANCED_MagicNumber||position.Symbol()!=_Symbol)continue;
      double current=position.PositionType()==POSITION_TYPE_BUY?SymbolInfoDouble(_Symbol,SYMBOL_BID):SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      double open=position.PriceOpen(),sl=position.StopLoss();
      if(position.PositionType()==POSITION_TYPE_BUY){
         if(current-open>TARGET_TrailingStart*g_Point){
            double new_sl=current-TARGET_TrailingStep*g_Point;
            if(new_sl>sl&&new_sl>open)trade.PositionModify(position.Ticket(),new_sl,position.TakeProfit());
         }
      }else{
         if(open-current>TARGET_TrailingStart*g_Point){
            double new_sl=current+TARGET_TrailingStep*g_Point;
            if((new_sl<sl||sl==0)&&new_sl<open)trade.PositionModify(position.Ticket(),new_sl,position.TakeProfit());
         }
      }
   }
}

void ExecuteTrading(){
   int maxTrades=AI_Mode!=AI_OFF?AITradingSystem::dynamicSettings.currentMaxTrades:RISK_MaxTrades;
   if(PositionsTotal()>=maxTrades)return;
   if(PORTFOLIO_UseHealthScore&&g_PortfolioHealth.score<PORTFOLIO_MinHealthScore){
      static bool healthWarningShown=false;
      if(!healthWarningShown){Print("⛔ التداول متوقف - صحة المحفظة منخفضة: ",DoubleToString(g_PortfolioHealth.score,1),"%");healthWarningShown=true;}
      return;
   }
   
   if(g_TurboSignal.active&&dailyTurboTrades<5000){
      double lot=TURBO_LotSize>0?TURBO_LotSize:CalculateLotSize()*g_TurboSignal.suggestedMultiplier;
      lot=MathMin(lot,TURBO_MaxRisk);
      ENUM_ORDER_TYPE type=g_TurboSignal.direction>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
      if(OpenTrade(type,lot,"TURBO_"+DoubleToString(g_TurboSignal.adxStrength,1))){
         dailyTurboTrades++;g_TurboSignal.active=false;TurboSystem::OnTradeExecuted();
      }
   }
   
   if(FORCE_Enable&&ConsecutiveLosses>=FORCE_AfterLosses&&dailyForceTrades<5000){
      if(ForceSystem::CanTrade()){
         int dir=monitoredForceDirection!=0?monitoredForceDirection:ForceSystem::GetDirection();
         if(dir!=0){
            double lot=FORCE_LotSize>0?FORCE_LotSize:CalculateLotSize()*g_ForceRecovery.recoveryMultiplier;
            lot=MathMin(lot,FORCE_MaxLot);
            ENUM_ORDER_TYPE type=dir>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
            if(OpenTrade(type,lot,"FORCE_"+IntegerToString(g_ForceRecovery.recoveryAttempts+1))){
               dailyForceTrades++;g_ForceRecovery.recoveryAttempts++;ForceSystem::OnTradeExecuted();
            }
         }
      }
   }
   
   if(g_ScalpingSignal.active&&dailyScalpingTrades<SCALP_MaxDailyTrades){
      double lot=SCALP_LotSize>0?SCALP_LotSize:CalculateLotSize()*0.8;
      ENUM_ORDER_TYPE type=g_ScalpingSignal.direction>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
      if(OpenTrade(type,lot,"SCALP_"+g_ScalpingSignal.pattern)){
         dailyScalpingTrades++;g_ScalpingSignal.active=false;ScalpingSystem::OnTradeExecuted();
      }
   }
   
   if(RANGE_Enable){
      int signal=RangeSystem::GetSignal();
      if(signal!=0){
         double lot=RANGE_LotSize>0?RANGE_LotSize:CalculateLotSize();
         ENUM_ORDER_TYPE type=signal>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
         if(OpenTrade(type,lot,"RANGE"))RangeSystem::OnTradeExecuted();
      }
   }
   
   if(INDICATOR_Enable&&dailyIndicatorTrades<INDICATOR_MaxDailyTrades){
      if(TimeCurrent()-lastIndicatorTrade>=INDICATOR_WaitSeconds){
         int signal=GetIndicatorSignal();
         if(signal!=0){
            double lot=INDICATOR_LotSize>0?INDICATOR_LotSize:CalculateLotSize();
            double adx=GetCurrentADX();
            if(adx>40){lot*=INDICATOR_StrongSignalMultiplier;Print("📈 تعزيز حجم اللوت للإشارة القوية - ADX: ",DoubleToString(adx,1));}
            ENUM_ORDER_TYPE type=signal>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
            string comment="INDICATOR";
            if(adx>40)comment+="_STRONG";else if(adx>25)comment+="_MODERATE";
            if(OpenTrade(type,lot,comment)){
               lastIndicatorTrade=TimeCurrent();dailyIndicatorTrades++;
               Print("📊 صفقة إنديكاتور #",dailyIndicatorTrades," - انتظار ",INDICATOR_WaitSeconds," ثانية قبل الصفقة التالية");
            }
         }
      }
   }
}

double GetCurrentPL(){
   double total=0;
   for(int i=0;i<PositionsTotal();i++){
      if(!position.SelectByIndex(i)||position.Magic()!=ADVANCED_MagicNumber)continue;
      total+=position.Profit()+position.Swap()+position.Commission();
   }
   return total;
}

double GetRSI(){double rsi[];if(CopyBuffer(h_RSI,0,0,1,rsi)==1)return rsi[0];return 50;}
double GetATR(){double atr[];if(CopyBuffer(h_ATR,0,0,1,atr)==1)return atr[0];return 0;}

string GetVolatilityLevel(){
   double atr=GetATR();if(atr==0)return "NORMAL";
   double avgRange=0;
   for(int i=1;i<=20;i++){double high=iHigh(_Symbol,MARKET_Timeframe,i),low=iLow(_Symbol,MARKET_Timeframe,i);avgRange+=(high-low);}
   avgRange/=20;double ratio=atr/avgRange;
   if(ratio>2.0)return "EXTREME";if(ratio>1.5)return "HIGH";if(ratio<0.5)return "LOW";
   return "NORMAL";
}

string GetMomentumDirection(){
   double momentum=GetMomentum(5);
   if(momentum>10)return "STRONG_UP";if(momentum>5)return "UP";
   if(momentum<-10)return "STRONG_DOWN";if(momentum<-5)return "DOWN";
   return "NEUTRAL";
}

double GetMomentum(int minutes){
   int bars=minutes;if(MARKET_Timeframe!=PERIOD_M1)bars=minutes/(int)PeriodSeconds(MARKET_Timeframe)*60;
   double close[];if(CopyClose(_Symbol,MARKET_Timeframe,0,bars+1,close)<bars+1)return 0;
   double change=(close[bars]-close[0])/g_Point;return change/bars;
}

double GetRangeSize(int minutes){
   int bars=minutes;if(MARKET_Timeframe!=PERIOD_M1)bars=minutes/(int)PeriodSeconds(MARKET_Timeframe)*60;
   double high[],low[];
   if(CopyHigh(_Symbol,MARKET_Timeframe,0,bars,high)<bars||CopyLow(_Symbol,MARKET_Timeframe,0,bars,low)<bars)return 0;
   return (high[ArrayMaximum(high)]-low[ArrayMinimum(low)])/g_Point;
}

string GetPriceChange(int minutes){
   double close[];int bars=minutes;
   if(MARKET_Timeframe!=PERIOD_M1)bars=minutes/(int)PeriodSeconds(MARKET_Timeframe)*60;
   if(CopyClose(_Symbol,MARKET_Timeframe,0,bars+1,close)<bars+1)return "0";
   double change=((close[bars]-close[0])/close[0])*100;return DoubleToString(change,2);
}

bool IsHighImpactNewsSoon(){
   if(!NEWS_Enable||AITradingSystem::newsCount==0)return false;
   datetime now=TimeCurrent();
   for(int i=0;i<AITradingSystem::newsCount;i++){
      if(AITradingSystem::upcomingNews[i].impact==NEWS_HIGH){
         int minutesUntil=(int)((AITradingSystem::upcomingNews[i].time-now)/60);
         if(minutesUntil>0&&minutesUntil<=NEWS_MinutesBeforeEvent)return true;
      }
   }
   return false;
}

string GetImpactString(ENUM_NEWS_IMPACT impact){
   switch(impact){case NEWS_LOW:return "Low";case NEWS_MEDIUM:return "Medium";case NEWS_HIGH:return "HIGH";}
   return "";
}

double GetVolumeRatio(){return VolumeBoostSystem::GetVolumeRatio();}

string GetSymbolType(){
   if(g_IsGold)return "GOLD";if(g_IsCrypto)return "CRYPTO";
   if(StringFind(_Symbol,"JPY")>=0)return "JPY_PAIR";if(StringFind(_Symbol,"EUR")>=0)return "EUR_PAIR";
   if(StringFind(_Symbol,"GBP")>=0)return "GBP_PAIR";return "FOREX";
}

string GetCurrentSession(){
   MqlDateTime time;TimeToStruct(TimeGMT(),time);int hour=time.hour;
   if(hour>=22||hour<7)return "ASIAN";if(hour>=7&&hour<8)return "ASIAN+EUROPEAN";
   if(hour>=8&&hour<13)return "EUROPEAN";if(hour>=13&&hour<17)return "EUROPEAN+AMERICAN";
   if(hour>=17&&hour<22)return "AMERICAN";return "UNKNOWN";
}

double GetCommission(){
   if(HistorySelect(0,TimeCurrent())){
      for(int i=HistoryDealsTotal()-1;i>=0;i--){
         ulong ticket=HistoryDealGetTicket(i);
         if(HistoryDealGetString(ticket,DEAL_SYMBOL)==_Symbol){
            double commission=HistoryDealGetDouble(ticket,DEAL_COMMISSION),volume=HistoryDealGetDouble(ticket,DEAL_VOLUME);
            if(volume>0)return MathAbs(commission/volume);
         }
      }
   }
   if(g_IsGold)return 0.5;if(g_IsCrypto)return 1.0;return 0.1;
}

void UpdatePortfolioHealth(){
   g_CurrentRisk=RiskMonitor::CalculateRisk();
   g_PortfolioHealth.score=100;
   g_PortfolioHealth.riskLevel=g_CurrentRisk.currentDrawdown;
   
   if(g_CurrentRisk.currentDrawdown>10)g_PortfolioHealth.score-=g_CurrentRisk.currentDrawdown;
   if(g_CurrentRisk.maxOpenLoss>AccountInfoDouble(ACCOUNT_BALANCE)*0.05)g_PortfolioHealth.score-=20;
   if(ConsecutiveLosses>3)g_PortfolioHealth.score-=ConsecutiveLosses*5;
   if(g_CurrentRisk.marginLevel<200&&g_CurrentRisk.marginLevel>0)g_PortfolioHealth.score-=20;
   
   double pl=GetCurrentPL();
   if(pl>0)g_PortfolioHealth.profitability=pl/AccountInfoDouble(ACCOUNT_BALANCE)*100;
   else g_PortfolioHealth.profitability=-MathAbs(pl)/AccountInfoDouble(ACCOUNT_BALANCE)*100;
   
   g_PortfolioHealth.score=MathMax(0,MathMin(100,g_PortfolioHealth.score));
   
   if(g_PortfolioHealth.score>=80)g_PortfolioHealth.recommendation="صحة ممتازة";
   else if(g_PortfolioHealth.score>=60)g_PortfolioHealth.recommendation="صحة جيدة";
   else if(g_PortfolioHealth.score>=40)g_PortfolioHealth.recommendation="تحذير - مراقبة";
   else if(g_PortfolioHealth.score>=20)g_PortfolioHealth.recommendation="خطر - تقليل المخاطر";
   else g_PortfolioHealth.recommendation="خطر شديد - إيقاف فوري";
}

void CheckMemoryUsage(){
   static datetime lastCheck=0;
   if(TimeCurrent()-lastCheck<300)return;
   lastCheck=TimeCurrent();
   
   if(ArraySize(g_TickBuffer)>256){
      Logger::LogError("CheckMemoryUsage","TickBuffer size exceeded: "+IntegerToString(ArraySize(g_TickBuffer)));
   }
   
   if(g_TickIndex>1000000){
      g_TickIndex=g_TickIndex%256;
      if(ADVANCED_EnableLogging)Print("🔧 تم إعادة تعيين TickIndex لتجنب overflow");
   }
}

void PerformanceOptimizedTick(){
   datetime now=TimeCurrent();
   
   if(now-g_LastTickUpdate>=1){
      g_LastTickUpdate=now;
      Bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
      Ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
      UpdateTrailingStop();
      HFTSystem::CheckSignals();
   }
   
   if(now-g_LastFullUpdate>=5){
      g_LastFullUpdate=now;
      UpdateMainTrend();
      TurboSystem::UpdateSignal();
      VolumeBoostSystem::UpdateSignal();
      ScalpingSystem::UpdateSignal();
      RangeSystem::UpdateRange();
      ForceSystem::UpdateSignal();
      USTPSystem::GetPrediction();
      UltraBalance::Check();
      SmartPortfolio::ManageSafePortfolio();
      ExecuteTrading();
      UpdatePortfolioHealth();
   }
   
   if(now-g_LastRiskCheck>=10){
      g_LastRiskCheck=now;
      g_CurrentRisk=RiskMonitor::CalculateRisk();
   }
   
   CheckMemoryUsage();
}

int OnInit(){
   InitializeSymbol();
   if(!InitializeIndicators())return INIT_FAILED;
   Print("=== معلومات ",_Symbol," ===");
   Print("الحد الأدنى للوت: ",SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN));
   Print("الحد الأقصى للوت: ",SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX));
   Print("خطوة اللوت: ",SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP));
   Print("==================");
   Logger::Initialize();
   Protection::Initialize();InitialBalance=AccountInfoDouble(ACCOUNT_BALANCE);DailyStartBalance=InitialBalance;
   LastDailyReset=StringToTime(TimeToString(TimeCurrent(),TIME_DATE));g_SystemInitialized=true;
   if(AI_Mode!=AI_OFF){AITradingSystem::InitializeDynamicSettings();AITradingSystem::InitializeSessionTimings();}
   if(PORTFOLIO_Enable){
      if(!SmartPortfolio::Initialize()){
         Print("❌ فشل تهيئة نظام المحفظة الذكية");
         return INIT_FAILED;
      }
   }
   for(int i=0;i<10;i++){
      g_SystemActivity[i].lastOpen=0;
      g_SystemActivity[i].isActive=false;
      g_SystemActivity[i].tradesOpen=0;
      g_SystemActivity[i].totalProfit=0;
   }
   EventSetTimer(ADVANCED_TimerInterval);
   Print("✅ Golden Finale EA v3.08 Enhanced Complete - تم التهيئة");
   Print("📊 الأنظمة المفعلة:");
   if(TURBO_Enable)Print("⚡ TURBO");if(FORCE_Enable)Print("💪 FORCE");
   if(HFT_Enable)Print("🚀 HFT");if(USTP_Enable)Print("🎯 USTP");
   if(BOOST_Enable)Print("📈 BOOST");if(RANGE_Enable)Print("📊 RANGE");
   if(SCALP_Enable)Print("✂️ SCALPING");if(ULTRA_Enable)Print("⚖️ ULTRA BALANCE");
   if(PORTFOLIO_Enable)Print("💼 ADVANCED PORTFOLIO");
   if(AI_Mode!=AI_OFF){
      Print("🤖 orioto.ai/live: ACTIVE - Mode: ",AI_Mode==AI_HAIKU?"HAIKU":AI_Mode==AI_SONNET?"SONNET":AI_Mode==AI_ADAPTIVE?"ADAPTIVE":"OFF");
      Print("⚙️ Dynamic Settings: ENABLED");Print("⚡ Session-Aware Timings: ENABLED");
      Print("🎯 M1/M5 Optimized Analysis: ENABLED");Print("📈 Expected Improvement: 70-90%+ for scalping");
      Print("👑 AI Full Control: ENABLED - Complete trading authority");
      Print("🌍 Session Awareness: ENABLED");Print("💹 Direct Trading: ENABLED - AI opens/closes trades");
      Print("📊 Max Concurrent Positions: ",AI_MaxPositions);Print("🎯 External APIs: ",(AI_UseExternalAPIs?"ENABLED":"DISABLED"));
      Print("💵 Estimated Cost: $0.5-1.0/day (with smart model selection)");
   }
   if(NEWS_Enable)Print("📰 NEWS Analysis");
   if(AI_Mode!=AI_OFF){
      Print("⚠️ تنبيه: تأكد من إضافة هذه المواقع في قائمة URLs المسموحة:");
      Print("1. https://api.anthropic.com");Print("2. https://nfs.faireconomy.media (للأخبار)");
      if(AI_UseExternalAPIs)Print("3. https://api.metals-api.com (للبيانات الخارجية)");
      Print("(أدوات > خيارات > Expert Advisors > السماح بـ WebRequest)");
      string testKey=AITradingSystem::GetAPIKey();
      if(testKey!=""){
         Print("✅ API Key Found - Starting orioto.ai Trading!");
         Print("🤖 orioto.ai Features (ENHANCED VERSION):");
         Print("• M1/M5 Optimized Analysis - PERFECT FOR SCALPING");
         Print("• Multi-timeframe confirmation - ENHANCED");
         Print("• Ultra-fast response times - OPTIMIZED");
         Print("• Smart model selection - WORKING");
         Print("• External API integration - READY");
         Print("• Emergency intervention - ENHANCED");
         Print("• Precision scalping mode - ACTIVE");
         Print("• Smart Ultra Balance - CORRECTED");
         Print("• Advanced Portfolio Management - ACTIVE");
         Print("• Risk Monitor - ENHANCED");
         Print("• System Lock Protection - ACTIVE");
         Print("• Performance Optimization - ENABLED");
      }else Print("❌ مفتاح API غير موجود - orioto.ai سيعمل في وضع المحاكاة");
   }
   Print("🎯 التداول على الفريمات القصيرة:");
   Print("• M1: ",MARKET_Timeframe==PERIOD_M1?"ACTIVE":"INACTIVE");
   Print("• M5: ",MARKET_SecondaryTimeframe==PERIOD_M5?"ACTIVE":"INACTIVE");
   Print("• محسن خصيصاً لـ XAUUSD");
   Print("🔊 التنبيهات الصوتية: ",PORTFOLIO_EnableSoundAlerts?"مفعلة":"معطلة");
   Print("🛡️ Risk Protection: ENHANCED");
   Print("📊 Logging System: ",ADVANCED_EnableLogging?"ACTIVE":"INACTIVE");
   return INIT_SUCCEEDED;
}

void OnDeinit(const int reason){
   EventKillTimer();ReleaseIndicators();Logger::Close();
   ZeroMemory(g_TickBuffer);ZeroMemory(g_LastHFTData);ZeroMemory(currentRange);
   ZeroMemory(g_BoostSignal);ZeroMemory(g_TurboSignal);ZeroMemory(g_ScalpingSignal);ZeroMemory(g_ForceRecovery);
   Print("🔚 Golden Finale EA Enhanced - إيقاف - سبب:",reason);
}

void OnTick(){
   if(!g_SystemInitialized||IsStopped())return;
   ResetDailyCounters();
   if(AI_Mode!=AI_OFF&&AI_SessionAware)AITradingSystem::UpdateCurrentSession();
   MqlTick tick;
   if(SymbolInfoTick(_Symbol,tick)){
      USTPSystem::AddTick(tick.bid,(long)MathRound(tick.volume));
      g_TickBuffer[g_TickIndex%256].price=tick.bid;g_TickBuffer[g_TickIndex%256].time=tick.time;
      g_TickBuffer[g_TickIndex%256].volume=(double)tick.volume;g_TickBuffer[g_TickIndex%256].spread=(tick.ask-tick.bid)/g_Point;
      g_TickBuffer[g_TickIndex%256].valid=true;g_TickIndex++;
   }
   g_IndicatorsReady=BarsCalculated(h_MA_Fast)>=MARKET_MinBarsForTrade&&BarsCalculated(h_MA_Slow)>=MARKET_MinBarsForTrade&&BarsCalculated(h_RSI)>=MARKET_MinBarsForTrade&&BarsCalculated(h_ADX)>=MARKET_MinBarsForTrade;
   if(!g_IndicatorsReady)return;
   
   PerformanceOptimizedTick();
   
   if(AI_Mode!=AI_OFF)AITradingSystem::sessionProfitLoss=GetCurrentPL();
   string info=StringFormat("Golden Finale EA v3.08 Enhanced\nالرصيد: $%.2f | الربح: $%.2f\nالصفقات: %d | خسائر متتالية: %d\nصحة المحفظة: %.1f%% | المخاطر: %.1f%%",AccountInfoDouble(ACCOUNT_BALANCE),AccountInfoDouble(ACCOUNT_BALANCE)-InitialBalance,PositionsTotal(),ConsecutiveLosses,g_PortfolioHealth.score,g_CurrentRisk.currentDrawdown);
   if(AI_Mode!=AI_OFF){
      info+="\n\n=== AI Status ("+(AI_Mode==AI_HAIKU?"HAIKU ONLY":AI_Mode==AI_SONNET?"SONNET ONLY":AI_Mode==AI_ADAPTIVE?"ADAPTIVE":"OFF")+") ===";
      info+="\nMarket State: "+IntegerToString(AITradingSystem::currentAnalysis.marketState);
      info+="\nConfidence: "+DoubleToString(AITradingSystem::currentAnalysis.confidence,1)+"%";
      info+="\nRisk: "+DoubleToString(AITradingSystem::currentAnalysis.riskScore,0);
      info+="\nCalls: "+IntegerToString(AITradingSystem::dailyCalls)+"/"+IntegerToString(AI_MaxDailyCalls);
      info+="\nSession: "+g_CurrentSession;
      info+="\nEmergency Mode: "+(AITradingSystem::sessionTiming.emergencySonnetOnly?"YES":"NO");
      info+="\nHaiku/Sonnet Calls: "+IntegerToString(AITradingSystem::haikuCallCount)+"/"+IntegerToString(AITradingSystem::sonnetCallCount);
      info+="\nNext Fast: "+IntegerToString((int)(AITradingSystem::GetFastAnalysisInterval()-(TimeCurrent()-AITradingSystem::lastFastAnalysis)))+"s";
      info+="\nNext Deep: "+IntegerToString((int)((AITradingSystem::GetDeepAnalysisInterval()-(TimeCurrent()-AITradingSystem::lastDeepAnalysis))/60))+"m";
      info+="\n\n=== M1/M5 Analysis ===";
      info+="\nM1 Trend: "+AITradingSystem::GetM1Analysis();
      info+="\nM5 Trend: "+AITradingSystem::GetM5Analysis();
      info+="\nCombined: "+GetMomentumDirection();
      if(AI_UseExternalAPIs&&g_ExternalData.dataValid){
         info+="\n\n=== External Data ===";
         info+="\nTrend: "+g_ExternalData.trend;
         info+="\nSentiment: "+g_ExternalData.sentiment;
      }
      if(AITradingSystem::dynamicSettings.lastModificationReason!=""){
         info+="\n\n=== Dynamic Settings ===";
         info+="\nMax Trades: "+IntegerToString(AITradingSystem::dynamicSettings.currentMaxTrades);
         info+="\nTarget: $"+DoubleToString(AITradingSystem::dynamicSettings.currentPortfolioTarget,2);
         info+="\nReason: "+AITradingSystem::dynamicSettings.lastModificationReason;
      }
      if(AITradingSystem::dynamicSettings.protectionOverridden){
         info+="\n\n⚡ PROTECTION OVERRIDDEN BY AI";
         info+="\nReason: "+AITradingSystem::dynamicSettings.overrideReason;
      }
   }else info+="\n\n=== AI Status: DISABLED ===";
   info+="\n\n=== Active Systems ===";
   if(g_TurboSignal.active)info+="\n⚡ TURBO";if(g_BoostSignal.active)info+="\n🚀 BOOST";
   if(g_ScalpingSignal.active)info+="\n✂️ SCALP";if(g_LastUSTPPrediction.direction!=0)info+="\n🎯 USTP";
   if(g_ForceRecovery.emergencyMode)info+="\n💪 FORCE";
   if(protectionActive&&!AITradingSystem::dynamicSettings.protectionOverridden)info+="\n🛡️ PROTECTION";
   if(AI_Mode!=AI_OFF&&AITradingSystem::emergencyStatus.required)info+="\n🚨 EMERGENCY";
   
   info+="\n\n=== ⏱️ System Timers ===";
   int turboWait=(int)MathMax(0,(TURBO_WaitSeconds-(TimeCurrent()-lastTurboTrade)));
   int forceWait=(int)MathMax(0,(FORCE_WaitSeconds-(TimeCurrent()-lastForceTrade)));
   int rangeWait=(int)MathMax(0,(RANGE_WaitSeconds-(TimeCurrent()-lastRangeTrade)));
   int scalpWait=(int)MathMax(0,(SCALP_WaitSeconds-(TimeCurrent()-lastScalpingTrade)));
   int indicatorWait=(int)MathMax(0,(INDICATOR_WaitSeconds-(TimeCurrent()-lastIndicatorTrade)));
   
   if(TURBO_Enable){
      info+="\n⚡ TURBO: ";
      if(turboWait>0)info+=IntegerToString(turboWait)+"s";
      else info+="Ready";
      if(monitoredTurboDirection!=0)info+=" [Dir:"+(monitoredTurboDirection>0?"↑":"↓")+"]";
   }
   
   if(FORCE_Enable&&ConsecutiveLosses>=FORCE_AfterLosses){
      info+="\n💪 FORCE: ";
      if(forceWait>0)info+=IntegerToString(forceWait)+"s";
      else info+="Ready";
      if(monitoredForceDirection!=0)info+=" [Dir:"+(monitoredForceDirection>0?"↑":"↓")+"]";
   }
   
   if(RANGE_Enable){
      info+="\n📊 RANGE: ";
      if(rangeWait>0)info+=IntegerToString(rangeWait)+"s";
      else info+="Ready";
      if(monitoredRangeDirection!=0)info+=" [Dir:"+(monitoredRangeDirection>0?"↑":"↓")+"]";
   }
   
   if(SCALP_Enable){
      info+="\n✂️ SCALP: ";
      if(scalpWait>0)info+=IntegerToString(scalpWait)+"s";
      else info+="Ready";
      if(monitoredScalpingDirection!=0)info+=" [Dir:"+(monitoredScalpingDirection>0?"↑":"↓")+"]";
   }
   
   info+="\n📈 INDICATOR: ";
   if(indicatorWait>0)info+=IntegerToString(indicatorWait)+"s";
   else info+="Ready";
   
   info+="\n\n=== Risk Metrics ===";
   info+="\nMax Drawdown: "+DoubleToString(g_CurrentRisk.maxDrawdown,1)+"%";
   info+="\nOpen Loss: $"+DoubleToString(g_CurrentRisk.maxOpenLoss,2);
   info+="\nMargin Level: "+DoubleToString(g_CurrentRisk.marginLevel,0)+"%";
   
   if(NEWS_Enable&&AI_Mode!=AI_OFF&&AITradingSystem::newsCount>0){
      info+="\n\n=== 📰 News Calendar ===";int shown=0;
      for(int i=0;i<AITradingSystem::newsCount&&shown<3;i++){
         if(AITradingSystem::upcomingNews[i].time>TimeCurrent()){
            int minutes=(int)((AITradingSystem::upcomingNews[i].time-TimeCurrent())/60);
            info+="\n";
            if(AITradingSystem::upcomingNews[i].impact==NEWS_HIGH)info+="🔴 ";else info+="🟡 ";
            info+=AITradingSystem::upcomingNews[i].currency+" - ";
            info+=IntegerToString(minutes)+" min";shown++;
         }
      }
      int nextHighImpact=AITradingSystem::GetMinutesToNextHighImpactNews();
      if(nextHighImpact>0&&nextHighImpact<=NEWS_MinutesBeforeEvent)info+="\n⚠️ HIGH IMPACT IN "+IntegerToString(nextHighImpact)+" MIN!";
   }
   Comment(info);
}

void OnTimer(){
   if(!g_SystemInitialized||IsStopped())return;
   
   static bool timerRunning=false;
   if(timerRunning)return;
   timerRunning=true;
   
   bool operationSuccess=false;
   
   if(AI_Mode!=AI_OFF){
      static datetime lastFastCall=0,lastDeepCall=0,lastNewsCall=0;
      datetime currentTime=TimeCurrent();
      
      int fastInterval=AITradingSystem::GetFastAnalysisInterval();
      if(currentTime-lastFastCall>=fastInterval){
         AITradingSystem::FastMarketScan();
         lastFastCall=currentTime;
      }
      
      int deepInterval=AITradingSystem::GetDeepAnalysisInterval();
      if(currentTime-lastDeepCall>=deepInterval){
         AITradingSystem::DeepMarketAnalysis();
         lastDeepCall=currentTime;
      }
      
      if(currentTime-lastNewsCall>=300){
         AITradingSystem::FetchAndAnalyzeNews();
         lastNewsCall=currentTime;
      }
      
      if(AITradingSystem::emergencyStatus.required){
         AITradingSystem::HandleEmergency();
      }
      
      operationSuccess=true;
   }
   
   timerRunning=false;
   
   if(!operationSuccess&&ADVANCED_EnableLogging){
      Logger::LogError("OnTimer","Timer operation failed");
   }
}

void OnTrade(){
   ConsecutiveLosses=0;g_LastLossAmount=0;g_ForceRecovery.totalLossAmount=0;
   datetime day_start=StringToTime(TimeToString(TimeCurrent(),TIME_DATE));
   if(HistorySelect(day_start,TimeCurrent())){
      int wins=0,losses=0;double totalProfit=0,totalLoss=0;
      for(int i=HistoryDealsTotal()-1;i>=0;i--){
         ulong ticket=HistoryDealGetTicket(i);
         if(HistoryDealGetInteger(ticket,DEAL_MAGIC)!=ADVANCED_MagicNumber||HistoryDealGetString(ticket,DEAL_SYMBOL)!=_Symbol||HistoryDealGetInteger(ticket,DEAL_ENTRY)!=DEAL_ENTRY_OUT)continue;
         double profit=HistoryDealGetDouble(ticket,DEAL_PROFIT)+HistoryDealGetDouble(ticket,DEAL_SWAP)+HistoryDealGetDouble(ticket,DEAL_COMMISSION);
         if(profit<0){
            g_LastLossAmount=MathAbs(profit);g_ForceRecovery.totalLossAmount+=g_LastLossAmount;
            ConsecutiveLosses++;losses++;totalLoss+=MathAbs(profit);
         }else{
            if(StringFind(HistoryDealGetString(ticket,DEAL_COMMENT),"FORCE")>=0)successfulRecoveries++;
            wins++;totalProfit+=profit;break;
         }
      }
      if(AI_Mode!=AI_OFF){
         AITradingSystem::sessionWins=wins;AITradingSystem::sessionLosses=losses;
         AITradingSystem::sessionProfitLoss=totalProfit-totalLoss;
         double currentDD=((DailyStartBalance-AccountInfoDouble(ACCOUNT_EQUITY))/DailyStartBalance)*100;
         if(currentDD>AITradingSystem::maxDrawdownToday)AITradingSystem::maxDrawdownToday=currentDD;
      }
   }
   g_ForceRecovery.consecutiveLosses=ConsecutiveLosses;
   if(g_ForceRecovery.totalLossAmount>=FORCE_EmergencyLossLevel){g_ForceRecovery.emergencyMode=true;g_ForceRecovery.recoveryMultiplier=FORCE_RecoveryMultiplier*1.5;}
   if(AI_Mode!=AI_OFF&&ConsecutiveLosses>0){
      Print("🤖 orioto.ai: تحليل الخسارة رقم ",ConsecutiveLosses);
      if(ConsecutiveLosses>=3){
         AITradingSystem::emergencyStatus.required=true;
         AITradingSystem::emergencyStatus.reason="3 خسائر متتالية - تدخل فوري";
         AITradingSystem::emergencyStatus.urgency=70;
         if(AI_DirectTrading){
            Print("🤖 orioto.ai: تفعيل وضع الطوارئ المتقدم");
            AITradingSystem::CloseLosingPositions();
            for(int i=0;i<5&&PositionsTotal()<AI_MaxPositions;i++){
               int direction=AITradingSystem::GetSmartDirectionM1M5();
               if(direction!=0){
                  ENUM_ORDER_TYPE type=direction>0?ORDER_TYPE_BUY:ORDER_TYPE_SELL;
                  double recoveryLot=CalculateLotSize()*(2.0+i*0.5);
                  AITradingSystem::ExecuteAITrade(type,"AI_RECOVERY_"+IntegerToString(i+1),"LOT="+DoubleToString(recoveryLot,2));
                  Sleep(100);
               }
            }
            g_TurboSignal.active=true;g_BoostSignal.active=true;UltraBalance::ForceIntervention();
         }
      }
   }
}

void OnChartEvent(const int id,const long&lparam,const double&dparam,const string&sparam){
   if(id>=CHARTEVENT_CUSTOM){
      int event_id=id-CHARTEVENT_CUSTOM;string message="";
      switch(event_id){
         case EVENT_ULTRA_BALANCE_TRIGGERED:message="تفعيل الموازنة الفورية - خسارة: $"+DoubleToString(dparam,2);break;
         case EVENT_HFT_SIGNAL:message="إشارة HFT - اتجاه:"+(lparam>0?"صعود":"هبوط")+" ثقة:"+DoubleToString(dparam,1)+"%";break;
         case EVENT_BOOST_SIGNAL:message="إشارة رفع الحجم - اتجاه:"+(lparam>0?"صعود":"هبوط")+" ثقة:"+DoubleToString(dparam,1)+"%";break;
         case EVENT_TURBO_SIGNAL:message="إشارة TURBO - ADX:"+DoubleToString(dparam,1);break;
         case EVENT_FORCE_SIGNAL:message="إشارة FORCE - ثقة:"+DoubleToString(dparam,1)+"%";break;
         case EVENT_SCALPING_SIGNAL:message="إشارة سكالبينج - اتجاه:"+(lparam>0?"صعود":"هبوط");break;
         case EVENT_USTP_SIGNAL:message="تنبؤ فوري - اتجاه:"+(lparam>0?"صعود":"هبوط")+" ثقة:"+DoubleToString(dparam,1)+"%";if(sparam!="")message+=" سبب:"+sparam;break;
         case EVENT_RANGE_SIGNAL:message="إشارة نطاق - حجم:"+DoubleToString(dparam,0)+" نقطة";break;
         case EVENT_AI_SIGNAL:message="🤖 AI Signal - "+(lparam>0?"BUY":"SELL")+" confidence:"+DoubleToString(dparam,1)+"%";if(sparam!="")message+=" type:"+sparam;break;
         case EVENT_NEWS_ALERT:message="📰 News Alert - High impact in "+IntegerToString((int)lparam)+" minutes";break;
         case EVENT_EMERGENCY_INTERVENTION:message="🚨 Emergency Intervention - urgency:"+DoubleToString(dparam,0)+"%";if(sparam!="")message+=" reason:"+sparam;break;
         case EVENT_SETTINGS_MODIFIED:message="⚙️ Settings Modified - "+sparam;break;
         case EVENT_PROTECTION_OVERRIDE:message="⚡ Protection Override - "+sparam;break;
         case EVENT_SESSION_CHANGE:message="📍 Session Change - "+sparam;break;
      }
      if(message!=""){Print("📢 حدث: ",message);if(ADVANCED_EnableLogging&&ADVANCED_LogLevel<=LOG_INFO){}}
   }
}
//+------------------------------------------------------------------+
